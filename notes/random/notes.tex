%-----------------------------------------------------------------------------%
%Packages%
\documentclass[12pt, a4paper, titlepage]{scrartcl}
\usepackage{amsmath, amsfonts, listings, amssymb, mathtools, amsthm} %Mathematical Expressions package
\usepackage{mathtools}
\usepackage[usenames, dvipsnames]{color} %Color naming packages
\usepackage[margin=1.5cm]{geometry}
\usepackage{float}
\usepackage{verbatim} %for code
\usepackage[pdftex]{graphics}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{tikz}
\usepackage{comment}
\usepackage[nottoc]{tocbibind}
%\usepackage[square]{natbib}
\usepackage{caption}
\usepackage{subcaption}

\addtokomafont{disposition}{\rmfamily}
\usetikzlibrary{arrows,shapes}

%Graphis Extensions
\DeclareGraphicsExtensions{.png, .jpg}
\parindent 0pt

% Predefined things such as commands, etc.

\newcommand{\aRel}[1] {
  \sim_{#1} 
}

\newcommand{\kripkeFrame}[2] {
  (#1, \aRel{#2})
}

\newcommand{\kripkeModel}[3] {
  (#1, \aRel{#2}, #3)
}

\newcommand{\frKripModel}[2] { % defined via Kripke Frame + valuation
  (#1, #2)
}

\newcommand{\actModel}[3]{
  (#1, \aRel{#2}, #3)
}

\newcommand{\actModelStates}[4] {
	(#1, \aRel{#2}, #3, #4)
}

\newcommand{\frActModel}[2] { % defined via Kripke Frame + Pre
  (#1, #2)
}

\newcommand{\note}[1]{\textsc{\textbf{#1}}}
\newcommand{\Universal}{$\mathcal{U}$}
\newcommand{\modalLog}{$\mathcal{L}$}
\newcommand{\modLogInf}{$\mathcal{L}_\inf$}
\newcommand{\epActLog}{\modalLog$([\alpha])$}
\newcommand{\epActLogCommonKnowledge}{\modalLog$([\alpha],\box^{*})$}

\newtheorem{defn}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corr}{Corrollary}
\newtheorem*{remrk}{Remark}

% Drawings of frames

\tikzstyle{vertex}=[circle,fill=black!25,minimum size=20pt,inner sep=0pt]
\tikzstyle{selected vertex} = [vertex, fill=red!24]
\tikzstyle{edge} = [draw,thick,->]
\tikzstyle{weight} = [font=\small]

%-----------------------------------------------------------------------------%
%Document%
\begin{document}

\section{Definitions}

\begin{defn} \label{frame}
	Let $\Sigma$ be a set and $R: A \to \mathcal{P}(S \times S)$, a function from agents to
	accessibility relations.
	Then the tuple $(\Sigma, R)$ is a frame.
\end{defn}

A frame represents a mathematical structure, but holds no meaningful information.
In order to give meaning and be able to draw conclusions from the frame, we can
construct a valuation function that transforms the frame into a model detailing
information.
\begin{defn} \label{model}
	Let $F = (\Sigma, R)$ be a frame, and $A$ a set of agents.
	Let $V: \mathbb{P} \to \mathcal{P}(\Sigma)$ be a function mapping any
	well-formed	sentence in $\mathbb{P}$ to a subset of $\Sigma$.
	We say $V$ is a valuation function on $F$.\\
	\\
	Then $M = \frKripModel{F}{V} = (\Sigma, R, V)$ is a Kripke
	model.
\end{defn}
A pointed model $M_s$ is a model $M = (\Sigma, R, V)$ along with a designated state $s \in S$.
A multi-pointed model is a model $M$ with a set of designated states, $T$.

\begin{defn} \label{evModel}
	Let $\mathcal{L}$ be a logical language.
	An event model $M = (\Sigma, R, pre)$ with preconditions defined on $\mathcal{L}$ consists of
	\begin{itemize}
		\item a domain $\Sigma$ of possible atomic action points
		\item an accessibility function, $R: A \to \mathcal{P}(S \times S)$, a function from agents to
		accessibility relations on $\Sigma$
		\item a precondiion function, $pre: \Sigma \to \mathcal{L}$ which maps an action point to a
		sentence in $\mathcal{L}S$
	\end{itemize}
\end{defn}

Pointed and multi-pointed event models are similarly defined to pointed and multi-pointed Kripke
models.

%Our models are now informative models that we can reason with.
%In an epistemic logic context, we say that each $s \in \Sigma$ is a possible
%world.
%Each relation in $\aRel{A}$ is an accessibility relation, such that $s_1 \sim_a
%s_2$ signifies an agent $a \in A$ considering that, if $s_1$ was the ``current"
%world $a$ would believe $s_2$ was possible.\\
%\\
%We define an event model as a frame with a precondition function, and extend it
%to take a set of 
%{\em More stuff follows: some things about event models, etc.}\\
%\\
%Let us consider the following operation
%
%\begin{defn} \label{gen_union_1}
%	Let $M^1 = \actModelStates{\Sigma_1}{A}{pre_1}{\Gamma_1}$ and $M^2 =
%	\actModelStates{\Sigma_2}{A}{pre_2}{\Gamma_2}$ be two event models with
%	designated states.\\
%	\\
%	Let $M^1 \sqcup_B M^2 = \actModelStates{\Sigma}{A}{pre}{\Gamma}$ be the disjoint
%	union of $M^1$ and $M^2$ for some group	of agents $B \subseteq A$, such that
%	\begin{itemize}
%		\item $\Sigma = \Sigma_1 \sqcup \Sigma_2$
%		\item $\aRel{A} = {\aRel{A}}_1 \sqcup {\aRel{A}}_2 \sqcup \{w \sim_b w' | b \in
%		B \land (w \in \Gamma_1 \land w' \in \Gamma_2 \lor w \in \Gamma_2 \land w' \in \Gamma_1)\}$
%		\item $pre(w) = pre_1(w)$ if $w \in \Sigma_1$ and $pre(w) = pre_2(w)$ if $w
%		\in \Sigma_2$
%		\item $\Gamma = \Gamma_1 \sqcup \Gamma_2$
%	\end{itemize}
%\end{defn}
%
%\begin{lemma}
%	The algebra (?)
%	\[
%		\phi = \phi ; \theta | \phi ^{\ast} | \phi \sqcup \theta | \text{announce} |
%		\text{skip} | \text{crash}
%	\]
%	generates all event models in {\bf K45}.
%\end{lemma}
%
%\begin{note}
%	Actually this isn't true.
%	As an example, you can generate a model outside of {\bf K45} and into ???.\\
%\end{note}
%\\
Let $L$ be the language of {\bf K45}.
We say $\mathcal{AM}$ is the class of all action models over $L$.
Then we say $\mathcal{AM}_{PA}$ is the class of all action models that
are public announcements of a sentence in $L$.\\
\\
Let us define the following action models
\begin{defn} \label{insanity}
Let $M = (\{ \sigma \}, R, \{(\sigma, \phi)\}) $ be an action model
where $\phi \in L$ and $\sigma$ is an action point.
Then $\mathcal{AM}_{IN} = \{M | \phi \in L\}$ is the class of all action models
that represent the onset of insanity.
\end{defn}

%We define an operation
%\begin{defn} \label{believe}
%Let $M^1, M^2 \in \mathcal{AM}$ and without loss of generality let $M^1$, $M^2$
%be disjoint.
%Let $A$ be the agents for an action model $M^1$ and $M^2$.
%Let $B \subseteq A$.
%Then $M^1 \rightarrow_B M^2 = \actModel{\Sigma}{}{pre}$ where
%\begin{itemize}
%  \item $\Sigma = \Sigma_1 \cup \Sigma_2$
%  \item $\sim = \sim_1 \cup \sim_2 \cup \{(a, b) | a \in \Sigma_1 \land b \in
%  \Sigma_2 \}$
%  \item $pre = pre_1 \cup pre_2$
%\end{itemize}
%\end{defn}
%$M = M^1 \rightarrow_B M^2$ is the operation such that after $M$'s execution, $B$ will
%believe $M^2$ is executed if any action in $M^1$ is executed.\\
%\\
%\begin{lemma} \label{gen_trees}
%Suppose $\phi$ is a formula and from $L_{\otimes \forall} \exists_B \phi$.
%Then $M \in \mathcal{AM}$ and after $M$'s execution $\models \phi$, the language
%\[
%  \phi = \phi ; \theta | \phi ^ {\ast} | \phi \rightarrow_b \theta | skip |
%  crash | announce | insanity
%\]
%will generate a model $M'$ that is bisimilar to $M$.
%\end{lemma}

We adopt the convention for pointed event models that $M^1 = \{\Sigma^1, R^1,
pre^1, T^1\}$ and $M^\alpha = \{\Sigma^\alpha,R^\alpha,pre^\alpha,T^\alpha\}$.\\
\\

%TODO: Add in citations
In FIXME, Hales demonstrates that it is possible to determine whether an
finite epistemic goal can be achieved.
Furthermore, if it is achievable Hales constructs event models that will realise
that goal.
We will focus on defining a framework that constructs these event models in a
recursive manner.
This facilitates an automated method for updating knowledge models to reflect a
knowledge state.\\
\\
The event models that Hales employs resemble finite trees.
We give a rigourous definition for them as follows
%\begin{defn} \label{finTree}
%%TODO: Add in the definition of a finite tree-like event model.
%Let $M = \{\Sigma, \sim, pre, T \}$ be a pointed event model.
%$M$ is a finite tree-like event model if
%\begin{itemize}
%	\item $\Sigma$ is a finite set
%	\item $T$ is a singleton set, $\{ r \}$ where $r \in \Sigma$ is the root of the tree
%	\item each action $s$ in $\Sigma \setminus \{ t \}$, for each agent $a \in A$ has only at most 
%	one action $p \in \Sigma$ such that $p \sim_a s$
%	\item each action $s$ in $\Sigma$ fulfills either of
%	\begin{itemize}
%		\item each accessibility relation from $s$ is of the form $s \sim t$ where $t \neq s$
%		\item each accessibility relation from $s$ is of the form $s \sim s$
%	\end{itemize}
%	\item let $s$ be an action in $\Sigma$; then there exists some sequence of actions $a_1, a_2,
%	\ldots, a_k \in \Sigma$ such that $a_1 = r$, $a_k = s$ and $a_1 \sim a_2$, $a_2 \sim a_3$,
%	$\ldots$, $a_{k-1} \sim a_k$
%\end{itemize}
%\end{defn}

\begin{defn} \label{finTree}
Let $M = (\Sigma, R, pre, r)$ be a pointed event model.
$M$ is a finite tree-like event model if
\begin{itemize}
	\item $\Sigma$, the set of possible actions is finite
	\item $r$ is the root of the tree and is not accessible from any other action
	\item for each $s \in \Sigma \setminus \{ r \}$ there is a unique agent $a \in A$ and a unique
	action $p \in \Sigma$ such that $(p,s) \in R(a)$
	\item for each $s \in \Sigma$ there exists a unique sequence of actions in $\Sigma$, $r = s_0,
	s_1, \ldots, s_n = s$ and a sequence of agents $a_1, a_2, \ldots, a_n$ such that $s_0 R_{a_1}
	s_1$, $s_1 R_{a_2} s_2$, $\ldots, s_{n-1} R_{a_n} s_n$
\end{itemize}
\end{defn}

In order to generate these models, we must construct an algebra that can construct event models.
However, we are unaware of any operations that are appropriate for building tree-likemodels.
We define an operation to describe a group of agents' belief with regards to the possible execution
of one event model instead another.

\begin{defn} \label{possOne}
Let $M^1$ and $M^2$ be multi-pointed event models, and without loss of
generality let $M^1$ and $M^2$ be disjoint.
Let $B$ be a subset of agents participant in $M^1$ or $M^2$.
We define $M = M^1 \to_B M^2$ as 
\begin{itemize}
  \item $\Sigma = \Sigma^1 \cup \Sigma^2$
  \item $\sim_a =
  \begin{cases}
    \sim^1_a \cup \sim^2_a & \text{if } a \notin C \\
    \displaystyle\bigcup \begin{array}{c}
      \sim^1_a \\
      \sim^2_a \\
      \{(s,t) | s \in T^1 \land t \in T^2 \}
    \end{array} & \text{if } a \in C 
  \end{cases}$
  \item $pre = pre^1 \cup pre^2$
  \item $T = T^1$
\end{itemize}
\end{defn}

$M^1 \to_B M^2$ indicates that if $M^1$ was executed, an agent in $B$ considers $M^2$ as another
possible update.
We can now use our new operation to construct finite tree-like event models.

%TODO: Wait what is a group announcement? Isn't the null-group the equivalent of
%an insanity model?

\begin{thm}
Let $\phi$ be a well-formed sentence.
Suppose an event model $M$ exists such that $\phi$ is true after its execution.
There is a finite tree-like event model $T$ such that after $T$'s execution $\phi$ is true.
\end{thm}

\begin{thm}
Suppose $M = (\Sigma, R, pre, r)$ is a finite tree-like event model.
$M$ can be constructed using insanity event models and $\to$.
\end{thm}
Let $M' = (\Sigma', R', pre', r')$ be a finite tree-like event model that is a submodel of $M$.
That is there is a sequence of action points in $\Sigma$, $r = s_0, s_1, \ldots, s_n = r'$ 
%\begin{proof}
%To prove this we shall show that any pointed subtree of $M$, $M'$, whose point
%is at its root can be constructed by group announcements, insanity event models
%and $\to$.
%We will induct on the subtrees of $M$.\\
%\\
%Suppose $M'$ is a leaf node of $M$, $m$.
%The leaf nodes of a tree-like event model resemble are public announcements.
%Let $M'$ be a pointed public announcement event model with its precondition the
%same as $m$.
%Then our induction hypothesis holds for $M'$ being a leaf node of $M$.\\
%\\
%Suppose $M'$ is an arbitrary subtree of $M$.
%Let $K^1$, $K^2$, $\ldots$, $K^n$ be the subtrees of $M'$ whose parent node is
%the root node of $M'$.
%Let the group of agents $A^i$ have relations from the root node of $M'$ to a
%subtree $K^i$.
%Furthermore, let us say that each of $K^1, K^2, \ldots, K^n$ fulfills the
%induction hypothesis.
%Consider the insanity model $P = (\Sigma,\varnothing,pre,T)$, such that
%\begin{itemize}
%  \item $\Sigma = \{ \sigma \}$
%  \item $pre = \{ (\sigma, \phi)\}$
%  \item $T = \{\sigma\}$
%\end{itemize}
%where $\Sigma$, the set of states of $P$ is the singleton set $\sigma$ and 
%$\phi$ is the precondition of the root node of $M'$.
%Then consider $M'' = ((\ldots((P \to_{A^1} K^1) \to_{A^2} K^2) \to_{A^3} \ldots)\to_{A^n} K^n)$.
%Thus the induction hypothesis holds for $M'$.
%\end{proof}
%
%%TODO: Fix this.
``Insanity models" are a somewhat cumbersome construct, since their only purpose
is to serve as intermediate nodes in the tree.
They have no meaning outside of a tree-like structure and their semantics are
unintuitive within the context of knowledge or belief.
It would thus be desirable to reduce our atomic models to only group
announcements, since group announcements have more meaning within the context of
knowledge.\\
\\
In order to do so, we must define an operation that ensures that if $M^1$ was to
be executed, a group of agents in $B$ would believe $M^2$ would be executed
instead.
%TODO: Add in the story/motivation --- why is this useful
\begin{defn} \label{possTwo}
Let $M^1$ and $M^2$ be multi-pointed event models, and without loss of
generality let $M^1$ and $M^2$ be disjoint.
Let $B$ be a subset of agents participant in $M^1$ or $M^2$.
We define $M = M^1 \mapsto_B M^2$ as 
\begin{itemize}
  \item $\Sigma = \Sigma^1 \cup \Sigma^2$
  \item $\sim_a =
  \begin{cases}
    \sim^1_a \cup \sim^2_a & \text{if } a \notin B \\
    %FIXME: Make this neater
    \bigcup \begin{array}{c}
      \sim^1_a \setminus \{(s,t) | s \in T^1 \} \\
      \sim^2_a \\
      \{(s,t) | s \in T^1 \land t \in T^2 \}
    \end{array} & \text{if } a \in B 
  \end{cases}$
  \item $pre = pre^1 \cup pre^2$
  \item $T = T^1$
\end{itemize}
\end{defn}

The ``meaning" of $M^1 \mapsto_B M^2$ would be that given a set of actions in
$M^1$ the agents in $B$ believe that one of a set of actions in $M^2$ was
executed instead.\\
\\
It would be desirable to see whether the class of public announcements, with
$\to$ and $\mapsto$ would be sufficient to construct all tree-like action
models.
Conversely, using insanity and public announcement event models with $\to$ should be sufficient to construct
all tree-like action models.
\begin{thm}
Let $M$ be a finite tree-like event model.
$M$ can be constructed by public announcements, $\to$ and $\mapsto$.
\end{thm}
\begin{proof}
To prove this we shall show that any pointed subtree of $M$, $M'$, whose point
is at its root can be constructed by public announcements, $\to$ and $\mapsto$.
We will induct on the subtrees of $M$.\\
\\
Suppose $M'$ is a leaf node of $M$, $m$.
The leaf nodes of a tree-like event model resemble are public announcements.
Let $M'$ be a pointed public announcement event model with its precondition the
same as $m$.
Then our induction hypothesis holds for $M'$ being a leaf node of $M$.\\
\\
Now, suppose $M'$ is an arbitrary subtree of $M$.
Let $K^1$, $K^2$, $\ldots$, $K^n$ be the subtrees of $M'$ whose parent node is
the root node of $M'$.
%TODO: tidy up the agent relations...?
Let the group of agents $A^i$ have relations from the root node of $M'$ to a
subtree $K^i$.
Furthermore, let us say that each of $K^1, K^2, \ldots, K^n$ fulfills the
induction hypothesis.
Consider the public announcement $P = \{\Sigma,\sim_{A^1},pre,T\}$, such that
\begin{itemize}
  \item $\Sigma = \{ \sigma \}$
  \item $\forall a \in A^1 \implies \sim_a = \{ (\sigma,\sigma) \}$
  \item $pre = \{ (\sigma, \phi)\}$
  \item $T = \{\sigma\}$
\end{itemize}
where $\Sigma$, the set of states of $P$ is the singleton set $\sigma$ and 
$\phi$ is the precondition of the root node of $M'$.
Then $M' = ((\ldots((P \mapsto_{A^1} K^1) \to_{A^2} K^2) \to_{A^3}
      \ldots)\to_{A^n} K^n)$.
%TODO: break things up more
\end{proof}
It is clear that adding disjoint union to either of these sets of operators
allows us to form all forests of tree-like event models.
It also provides us with an alternate way to form tree-like event models.\\
\\
%TODO: this isn't true; how to resolve this properly? definition is not sound at the moment
However, we cannot form tree-like event models with just $\mapsto$, or even
$\mapsto$ and disjoint union.
Consider $M = ( \{\sigma_1, \sigma_2, \sigma_3, \sigma_4\}, \{\sim_a =
\{(\sigma_1,\sigma_2),(\sigma_1,\sigma_3),(\sigma_2,\sigma_2),(\sigma_3,\sigma_3)\},
\sim_b =
\{(\sigma_1,\sigma_3),(\sigma_1,\sigma_4),(\sigma_3,\sigma_3),(\sigma_4,\sigma_4)\}\},
pre)$.
We cannot form this model using $ \mapsto $, due to $\sim_a \cap \sim_b \neq
\varnothing$.\\
\\
We can form other interesting models besides trees using these operators.
Let $B$, $C \subseteq A$, the set of all agents.
Suppose $ann(\phi)_B$ is the event model of the group announcement of $\phi$.
We define $skip$ as the public announcement of $\top$ to all agents.
Then $ann(\phi)_B \to_C skip$ models all agents in $B$ learning $\phi$ whilst all agents in $C$
believe that nothing has changed.
Similarly, $skip \mapsto_C ann(\phi)_A$ models the announcement of $\phi$ by an external agent that
the agents in $C$ trust, but the agents in $B$ do not.
\end{document}
