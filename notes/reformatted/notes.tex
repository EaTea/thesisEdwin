%-----------------------------------------------------------------------------%
%Packages%
\documentclass[12pt, a4paper, titlepage]{article}
\usepackage{amsmath, amsfonts, listings, amssymb, mathtools, amsthm} %Mathematical Expressions package
\usepackage{mathtools}
\usepackage[usenames, dvipsnames]{color} %Color naming packages
\usepackage[margin=1.5cm]{geometry}
\usepackage{float}
\usepackage{verbatim} %for code
\usepackage[pdftex]{graphics}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{tikz}
\usepackage{comment}
\usepackage[nottoc]{tocbibind}
%\usepackage[square]{natbib}
\usepackage{caption}
\usepackage{subcaption}

\usetikzlibrary{arrows,shapes}

%Graphis Extensions
\DeclareGraphicsExtensions{.png, .jpg}
\parindent 0pt

% Predefined things such as commands, etc.

\newtheorem{defn}{Definition}[subsection]
\newtheorem{thm}{Theorem}[subsection]
\newtheorem{lemma}{Lemma}[subsection]
\newtheorem{corr}{Corrollary}[subsection]
\newtheorem*{remrk}{Remark}

\numberwithin{equation}{section}

\newcommand{\cover}{\bigtriangledown}
\newcommand{\sqex}[1]{[{#1}]}
\newcommand{\anex}[1]{\langle {#1} \rangle}
\newcommand{\lang}{\mathcal{L}}
\newcommand{\langRefine}{\lang_{\forall}}
\newcommand{\langActEx}{\lang_{\otimes}}
\newcommand{\langArbAct}{\lang_{\otimes\forall}}
\newcommand{\langProp}{\lang_0}

\newcommand{\AXK}{{\bf K}}
\newcommand{\AXAML}{${\bf AML_{\AXK}}$}
\newcommand{\AXRML}{${\bf RML_{\AXK}}$}
\newcommand{\AXAAML}{${\bf AAML_{\AXK}}$}

\newcommand{\axP}{{\bf P}}
\newcommand{\axK}{{\bf K}}
\newcommand{\axMP}{{\bf MP}}
\newcommand{\axNecK}{{\bf NecK}}
\newcommand{\axAN}{{\bf AN}}
\newcommand{\axAP}{{\bf AP}}
\newcommand{\axAC}{{\bf AC}}
\newcommand{\axAK}{{\bf AK}}
\newcommand{\axAU}{{\bf AU}}
\newcommand{\axNecA}{{\bf NecA}}
\newcommand{\axR}{{\bf R}}
\newcommand{\axRP}{{\bf RP}}
\newcommand{\axRK}{{\bf RK}}
\newcommand{\axRComm}{{\bf RComm}}
\newcommand{\axRDist}{{\bf RDist}}
\newcommand{\axNecR}{{\bf NecR}}

\newcommand{\kripkeClass}{\mathcal{K}}
\newcommand{\eventClass}{\mathcal{AM}}
\newcommand{\insaneClass}{\eventClass_{IN}}
\newcommand{\publicAnnClass}{\eventClass_{PA}}
\newcommand{\treeClass}{\eventClass_{TR}}
\newcommand{\forestClass}{\eventClass_{FOR}}

\newcommand{\FIXME}{{\bf FIXME}}
% Drawings of frames

\tikzstyle{vertex}=[circle,fill=black!25,minimum size=20pt,inner sep=0pt]
\tikzstyle{selected vertex} = [vertex, fill=red!24]
\tikzstyle{edge} = [draw,thick,->]
\tikzstyle{weight} = [font=\small]

%-----------------------------------------------------------------------------%
%Document%
\begin{document}

\tableofcontents

\pagebreak

\section{Technical preliminaries}
In order to discuss event model synthesis, we first define essential concepts regarding event
models and the semantics of the logics we are working within.

\subsection{Models}

\begin{defn} \label{frame}
	Let $\Sigma$ be a set of atoms and $R: A \to \mathcal{P}(S \times S)$, a function from agents to
	accessibility relations.
	Then the tuple $(\Sigma, R)$ is a frame.
\end{defn}

A frame represents a mathematical structure, but holds no meaningful information.
In order to give meaning and be able to draw conclusions from the frame, we can
construct a valuation function that transforms the frame into a model detailing
information.
\begin{defn} \label{model}
	Let $L$ be a logical language.
	Let $F = (\Sigma, R)$ be a frame, and $A$ a set of agents.
	In the context of epistemic modal logic, $\Sigma$ is a set of atomic knowledge points.
	Let $V: L \to \mathcal{P}(\Sigma)$ be a function mapping any
	well-formed	sentence in $L$ to a subset of $\Sigma$.
	We say $V$ is a valuation function on $F$.\\
	\\
	Then $M = (F, V) = (\Sigma, R, V)$ is a Kripke
	model.
\end{defn}
A multi-pointed model is a model $M = (\Sigma, R, V)$ with a set of designated states, $T$.
When $T = \{s\}$ is a single state, we say that the model is a pointed model and write $M_s$.
We say $\kripkeClass$ is the class of all Kripke models.

\begin{defn} \label{evModel}
	Let $L$ be a logical language.
	Let $F = (\Sigma, R)$ be a frame, and $A$ a set of agents.
	An event model $M = (\Sigma, R, pre)$ with preconditions defined on $\mathcal{L}$ consists of
	\begin{itemize}
		\item a domain $\Sigma$ of possible atomic action points
		\item an accessibility function, $R: A \to \mathcal{P}(S \times S)$, a function from agents to
		accessibility relations on $\Sigma$.\\
		We refer to $R(a)$ as $R_a$.
		We will refer to all accessible action points from $s$ as $s R_a$, and all action points that
		can access $t$ as $R_a t$.
		Furthermore, we say $s R_a t$ means $t$ is $a$-accessible from $s$.
		\item a precondition function, $pre: \Sigma \to \mathcal{L}$ which maps an action point to a
		sentence in $\mathcal{L}$
	\end{itemize}
\end{defn}

Pointed and multi-pointed event models are similarly defined to pointed and multi-pointed Kripke
models.
We adopt the convention for pointed event models that $M^1 = \{\Sigma^1, R^1,
pre^1, T^1\}$ and $M^\alpha = \{\Sigma^\alpha,R^\alpha,pre^\alpha,T^\alpha\}$.
Furthermore, in literature both of the terms event models and action models are used to describe
the same concept, and we use them interchangeably throughout this paper to refer to event models.

\begin{defn} \label{evModelEx}
Let $M = (\Sigma, R, V) \in L$. We define event model execution for an event model $N = (\Sigma^N,
		R^N, pre^N) \in
\mathcal{AM}$ as follows.
The result of executing $N$ on the model $M$ is denoted by $M \otimes N = M' = (\Sigma', R', V')$ where
\begin{itemize}
	\item $\Sigma' = \{(s,u) | s \in \Sigma, u \in \Sigma^N \text{ such that } M_s \vdash pre^N(u)\}$
	\item $(s, u) R_a' (t, v) \iff s R_a t \land u R_a^N v$
	\item $V'((s,u)) = V(s)$
\end{itemize}
We define pointed event model execution as $M_s \otimes N_u = (M \otimes N)_{(s, u)}$.
This pointed model execution is only sensible if and only if $M_s \models pre^N(u)$ and thus $(s,u)
	\in \Sigma'$.
\end{defn}

We say $\eventClass$ is the class of all event models.

\begin{defn} \label{pub}
Let $M = (\{ \sigma \}, R, \{ (\sigma, \phi)\})$ be an event model.
Let $\sigma$ be a single action point and $R_a = \{(\sigma, \sigma)\}$ for each $a \in A$ and $\phi
\in \mathcal{L}$.
Then $M$ is a public announcement of $\phi$.
We say $\publicAnnClass$ is the class of all action models that
are public announcements of a sentence in $L$.
\end{defn}

\begin{defn} \label{insanity}
Let $M = (\{ \sigma \}, \varnothing, \{(\sigma, \phi)\}) $ be an action model
where $\phi \in L$ and $\sigma$ is an action point.
$M$ represents the truthful announcement of $\phi$ causing all agents to renounce all their beliefs.
$\insaneClass = \{M | \phi \in L\}$ is the class of all such action models.
\end{defn}
We call this class of models ``insanity models".
This is because after the execution of an insanity model, all agents have renounced every belief
they hold.
They thus believe in everything --- that both propositions $p$ and $\neg p$ hold.
Allowing them to believe such contradictions means that they are effectively insane.

\subsection{Bisimilarity, simulation and refinement}

\begin{defn} \label{bisimKripke}
	Let $M$, $M'$ be Kripke models and $\sim \subseteq \Sigma \times \Sigma'$ be a non-empty binary
	relation such that
	\begin{itemize}
		\item {\bf atoms}: for each $s \in \Sigma$ and $s' \in \Sigma'$ such that $s \sim s'$, $V(s) = V'(s')$
		\item {\bf front-$a$}: for each $s \in \Sigma$ such that $s \sim s'$, for each $t$ such that
		$s R_a t$ then there exists $t'$ such that $s' R_a' t'$ and $t \sim t'$
		\item {\bf back-$a$}: for each $s' \in \Sigma'$ such that $s \sim s'$, for each $t$ such that
		$s' R_a' r'$ then there exists $t$ such that $s R_a t$ and $t \sim t'$
	\end{itemize}
	$\sim$ is a bisimulation between $M$ and $M'$ if and only if {\bf atoms} holds and {\bf front-$a$}
	and {\bf back-$a$} hold for each $a \in A$.
	We denote $M$ and $M'$ being bisimilar by $M \sim M'$.
\end{defn}
% \FIXME: add in citations

\begin{lemma} \label{bisimEquivalence}
	The relation $\sim$ is an equivalence relation.
\end{lemma}

This is a well-known result shown by de Rijke, Venema and Blackburn in \FIXME.

\begin{defn} \label{nBisimKripke}
Let $M_s, M'_{s'} \in \kripkeClass$.
We define $n$-bisimilarity inductively as follows.
We say that $M_s$ is $0$-bisimilar to $M'_{s'}$ if and only if $V(s) = V'(s)$.
Then for $n > 0$ we say that $M_s$ is $n$-bisimilar to $M'_{s'}$ if and only if for every $a \in A$
\begin{itemize}
	\item $M_s$ is $n-1$-bisimilar to $M'_{s'}$
	\item {\bf $n$-front-$a$}: for each $t \in s R_a$, there is a $t' \in s' R'_a$ such that $M_t$ is
	$n-1$-bisimilar to $M'_{t'}$
	\item {\bf $n$-back-$a$}: for each $t' \in s' R'_a$ there is a $t \in s R_a$ such that $M_t$ is
	$n-1$-bisimilar to $M'_{t'}$
\end{itemize}
We denote $M_s$ and $M'_{s'}$ being $n$-bisimilar by $M_s \sim_n M'_{s'}$.
\end{defn}

\begin{defn} \label{refinement}
Let $B \subseteq A$ and $M$ and $M'$ be Kripke models. A non-empty relation $\lesssim \subseteq \Sigma
\times \Sigma'$ is a $B$-simulation if and only if it satisfies {\bf atoms}, {\bf forth-$a$} for
every $a \in A$ and {\bf back-$a$} for every $a \in A \setminus B$.
\end{defn}
If $(\sigma, \sigma') \in \lesssim$ then we say $M'_{\sigma'}$ is a $B$-simulation of $M_\sigma$ and
$M_\sigma$ a $B$-refinement of $M'_{\sigma'}$.
We write $M_{\sigma} \lesssim M'_{\sigma'}$ or equivalently $M'_{\sigma'} \gtrsim M_{\sigma}$.

\begin{lemma} \label{refinementPreorder}
The relation $\lesssim_B$ is a preorder.
\end{lemma}
This is shown by van Ditsmarch and French in \FIXME.

\begin{lemma} \label{bisimilarIsRefinement}
Let $M_\sigma, M'_{\sigma'} \in \kripkeClass$ and $B \subseteq A$.
Then $M_\sigma \sim M'_{\sigma'} \implies M_\sigma \lesssim_B M'_{\sigma'}$.
\end{lemma}

\begin{defn} \label{brestrict}
Let $B \subseteq A$ and let $N \in \eventClass$. Then $N$ is a $B$-restricted event model if and
only if for every $u \in \Sigma$ and every $M_s \in \kripkeClass$ such that $M_s \models pre(u)$ we
have $M_s \otimes N_u \gtrsim_B M_s$.
We say the class of $B$-restricted action models is $\eventClass_B$.
\end{defn}
%\FIXME: citation here

\subsection{Language semantics}
We now discuss the semantics and syntax of several different languages, culminating with language of
arbitrary action model logic which will rely upon each of the languages we discuss.

\begin{defn} \label{propLogic}
Let $M = (\Sigma, R, V) \in \kripkeClass$.
The language of propositional logic $\langProp$ is inductively defined by
\[
	\phi ::== p | \neg \phi | (\phi \land \phi)
\]
The interpretation of $\phi \in \langProp$ in the logic $K$ is defined inductively as
\begin{itemize}
	\item $M_s \models p$ iff $p \in V(s)$
	\item $M_s \models \neg \phi$ iff $M_s \not \models \phi$
	\item $M_s \models \phi \land \psi$ iff $M_s \models \phi$ and $M_s \models \psi$
\end{itemize}
for $s \in \Sigma$.
\end{defn}
We will adopt the standard abbreviations for propositional logic, such as $\phi \lor \phi =
\neg(\neg \phi \land \neg \phi)$.
These are defined in \FIXME.

\begin{defn} \label{modalLogic}
Let $M = (\Sigma, R, V) \in \kripkeClass$.
The language of modal logic $\lang$ is $\langProp$ with the additional inductive case
\[
	 \Box_a \phi
\]
The interpretation of $\phi \in \lang$ in the logic $K$ is the same as $\langProp$, with the
additional inductive case
\[
	M_s \models \Box_a \phi \text{ iff for every }t \in s R_a: M_t \models \phi
\]
for $a \in A$ and $s \in \Sigma$.
\end{defn}
The Kripke semantics for modal logic are well-known.
We will adopt the standard abbreviations for Kripke semantics --- see \FIXME.\\
\\
%\FIXME: Add in citations and stuff
In epistemic logics, the formula $\Box_a \phi$ is often read as ``$a$ knows/believes $\phi$", while
its dual operator, $\Diamond_a \phi$ means ``$a$ considers $\phi$ possible".
We also employ the abbreviation $\Box_B \phi$ where $B \subseteq A$ to be $\bigwedge_{b \in B}
\Box_b \phi$.
In the case where $B = A$ we write $M_s \models \Box \phi$.\\
\\
We say that a formula $\phi$ is satisfied by a pointed model Kripke model $M_s \in \kripkeClass$ iff
$M_s \models \phi$.
We say that $\phi$ is satisfied by a model $M = (\Sigma, R, V)$ (denoted by $M \models \phi$) iff
for all $\sigma \in \Sigma$, $M_\sigma \models \phi$.
Furthermore, $\phi$ is valid in a class of Kripke models $\kripkeClass$ iff for every model $M \in
\kripkeClass$, $M \models \phi$.\\
\\
%\FIXME: Add citation
In addition to $\Box_a$ we introduce the cover operator $\cover_a$, as first defined in \FIXME.
\begin{defn} \label{coverDef}
Let $\Gamma \subseteq \lang$ be a finite set of formulae.
Then
\[
  \cover_a \Gamma ::== \Box_a \bigvee_{\gamma \in \Gamma} \gamma \land
  \bigwedge_{\gamma \in \Gamma} \Diamond_a \gamma
\]
Similarly, if $B \subseteq A$, then $\cover_B \Gamma ::== \bigwedge_{b \in B}
\cover_b \Gamma$.
\end{defn}
We note that this is a simple abbreviation, and we can define $\Box_a$ and
$\Diamond_a$ in terms of it.
$\Box_a \phi \iff \cover_a \phi \lor \cover_a \varnothing$, while $\Diamond_a
\phi \iff \cover_a \{\phi, \top\}$.
$\cover$ is the basis for the axiomatisation of refinement modal logic.

\begin{defn} \label{actModelLogic}
Let $M = (\Sigma, R, V) \in \kripkeClass$ be a Kripke model and $N = (\Sigma^N, R^N, pre^N) \in
\eventClass$ a multi-pointed event model.
The interpretation of $\phi \in \langActEx$ is the same as its interpretation in $\lang$
(\ref{modalLogic}), but with the additional
inductive cases
\begin{itemize}
	\item $M_s \models \sqex{N_\sigma} \phi$ iff $M_s \models \phi \implies M_s \otimes N_\sigma \models
	\phi$ (see Definition \ref{evModelEx})
	\item $M_s \models \sqex{N_T} \phi$ iff for every $\sigma \in T$, $M_s \models \sqex{N_\sigma} \phi$ 
\end{itemize}
\end{defn}
$\sqex{N_\sigma} \phi$ can be read as ``the successful execution of the informative update modelled by
$N_\sigma$ will result in $\phi$ being true".
Similarly, $\sqex{N_T} \phi$ can be read as ``the successful execution of the informative update
modelled by $N_T$ will result in $\phi$ being true".
If $T = \Sigma^N$ then we write $M_s \models \sqex{N} \phi$.\\
\\
We adopt the standard convention for the dual operators, with $\anex{ N_\sigma } \phi$ being
read as ``the successful execution of the informative update modelled by $N_\sigma$ may result in
$\phi$ being true".
Again, $\anex{ N_T } \phi$ can be read as ``the successful execution of the informative
update modelled by $N_T$ may result in $\phi$ being true".

%\FIXME: Add in citations to Baltag, Moss and Solecki

\begin{defn} \label{refineLogic}
Let $M = (\Sigma, R, V) \in \kripkeClass$ be a Kripke model.
The interpretation of $\phi \in \langRefine$ in the logic $K_\forall$ is the same as $\lang$
(\ref{modalLogic}), but with the additional inductive case
\[
	M_s \models \forall_B \phi \text{ iff } \forall M'_{s'} \in \eventClass \text{ such that } M'_{s'}
	\lesssim_B M_s : M'_{s'} \models \phi
\]
\end{defn}
We read the formula $\forall_B \phi$ as ``for any $B$-refinement, $\phi$ will hold".
Its dual, $\exists_B \phi$ can be read as ``there is a $B$-refinement such that $\phi$ will hold".
As in the previous operations, when $B = A$ we will write $\forall \phi$.
In addition, when $B = \{b\}$ we write $\forall_b$ and $\exists_b$.

%\FIXME: Add in citations to Tim, Rowan, James

\begin{defn} \label{arbActLogic}
The language of arbitrary action model logic, $\langArbAct$ is first defined in \FIXME.
We inductively define $\langArbAct$ by
\[
	\phi ::== p | \neg \phi | \phi \land \phi | \Box_a \phi | \sqex{N_T} \phi | \forall_B \phi
\]
for $N_T \in \eventClass$ and $B \subseteq A$.
\end{defn}
$\langArbAct$ is $\langActEx$ with $\forall_B$ and is also $\langRefine$ with $\sqex{N_T}$.

%\FIXME: Add in James' alternate definition for \forall

%\FIXME: Add in the citations of James

\subsubsection{Miscellaneous Semantic Results}
We provide other results that we will use in the main technical findings of this paper.

\begin{defn} \label{bisimEvent}
	Let $M, M' \in \eventClass$ with preconditions defined on $\langArbAct$.
	A non-empty relation $\sim$ on $M \times M'$ is a bisimulation if and only if for every $a \in A$
	and $(s, s') \in \sim$, the following three conditions hold:
	\begin{itemize}
		\item {\bf pre}: $pre(s) \iff pre'(s')$
		\item {\bf forth-$a$}: for every $v \in s R_a$ there is a $v' \in s' R'_a$ such that $(v,v') \in
		\sim$
		\item {\bf back-$a$}: for every $v' \in s' R'_a$ there is a $v \in s R_a$ such that $(v,v') \in
		\sim$
	\end{itemize}
	If $(s, s') \in \sim$ we write $M_s \sim M'_{s'}$ to denote that $M_s$ and $M'_{s'}$ are bisimilar and
	that there is a bisimulation between $M_s$ and $M'_{s'}$.
\end{defn}

\begin{lemma} \label{eventModelsRefine}
Let $M_\sigma \in \eventClass$ be an event model and let $N_s \in \kripkeClass$ be a Kripke
model such that $N_s \models pre(\sigma)$.
Then $N_s \otimes M_\sigma \lesssim N_s$.
\end{lemma}

\begin{lemma} \label{eventModelEquivalent}
Let $M_\sigma$, $M'_{\sigma'} \in \eventClass$ be event models such that $M_\sigma \sim M'_{\sigma'}$
and let $N_s \in \kripkeClass$ such that $N_s \models pre(\sigma)$.
Then $N_s \otimes M_\sigma \sim N_s \otimes M'_{\sigma'}$.
\end{lemma}

\begin{lemma} \label{nBisimilarKripkeExec}
Let $M_s$, $M'_{s'} \in \kripkeClass$ such that $M_s \sim_n M'_{s'}$ and let $N_t \in \eventClass$.
For any $\phi \in \lang$ with modal depth $mod(\phi) \leq n$ then $M_s \otimes N_t \models \phi
\iff M'_{s'} \otimes N_t \models \phi.$
\end{lemma}

\begin{defn} \label{nBisimEvent}
	Let $M_s, M'_{s'} \in \eventClass$ with preconditions defined on $\langArbAct$.
	We inductively define $n$-bisimilarity for event models.
	We say $M_s$ is $0$-bisimilar to $M'_{s'}$ if and only if $pre(s) \iff pre'(s')$.
	Then for $n>0$ $M_s$ is $n$-bisimilar to $M'_{s'}$ if and only if each of the following hold
	\begin{itemize}
		\item $M_s$ is $n-1$-bisimilar to $M'_{s'}$
		\item {\bf $n$-forth-$a$} for every $t \in s R_a$, there is a $t' \in s' R'_a$ such that $M_t$ is
		$n-1$-bisimilar to $M'_{t'}$
		\item {\bf $n$-back-$a$} for every $t' \in s' R'_a$, there is a $t \in s R_a$ such that $M_t$ is
		$n-1$-bisimilar to $M'_{t'}$
	\end{itemize}
	We write $M_s \sim_n M'_{s'}$ to denote that $M_s$ is $n$-bisimilar to $M'_{s'}$.
\end{defn}

\begin{lemma} \label{nBisimilarEventExec}
	Let $M_s, M'_{s'} \in \eventClass$ such that $M_s \sim_n M'_{s'}$ and $N_t \in \kripkeClass$.
	For any $\phi \in \lang$ with modal depth $mod(\phi) \leq n$ then $N_t \otimes M_s \models \phi
	\iff N_t \otimes M'_{s'} \models \phi$.
\end{lemma}

%\FIXME: WHO?! Please cite.

\begin{defn} \label{coverNormal}
A formula in cover disjunctive normal form is defined inductively as
\[
	\alpha ::== \pi \land \bigwedge_{b \in B} \cover_b \Gamma_b | \alpha \lor \alpha
\]
where $\pi \in \langProp$, $B \subseteq A$ and for every $b \in B$, $\Gamma_b$ is a finite set of
formulae in cover disjunctive normal form.
\end{defn}

\begin{lemma} \label{allInCoverNormal}
Every formula of $\lang$ is equivalent to a formula in cover disjunctive normal form.
\end{lemma}

\subsection{Axiomatisations}
We will present axiomatisations derived by Hales for $\langArbAct$.
To construct this axiomatisation, we first begin by presenting an axiomatisation for $\lang$, an
axiomatisation for $\langActEx$ and an axiomatisation for $\langRefine$.\\
\\
We say that a formula $\phi$ is provable under an axiomatisation if and only if it can be derived by
some finite sequence of axioms and rules within that axiomatisation.
We denote that $\phi$ is provable by $\vdash \phi$.
When discussing provability, it should be contextually clear which axiomatisation we are using.

\begin{defn} \label{axiomK}
The axiomatisation \AXK consists of the following axioms
\begin{alignat*}{2}
	& \axP && \quad \text{All propositional tautologies} \\
	& \axK && \quad \Box_a(\phi \implies \psi) \implies (\Box_a \phi \implies \Box_a \psi)
\end{alignat*}
and the following rules
\begin{alignat*}{2}
	& \axMP && \quad \text{From $\vdash \phi \implies \psi$ and $\vdash \phi$, infer $\vdash \psi$} \\
	& \axNecK && \quad \text{From $\vdash \phi$, infer $\vdash \Box_a \phi$}
\end{alignat*}
\end{defn}

\begin{lemma} \label{axiomKSoundComplete}
The axiomatisation \AXK is sound and complete with respect to the logic $\lang$.
\end{lemma}

\begin{defn} \label{axiomAML}
The axiomatisation \AXAML contains the axioms and rules from \AXK, as well as the following axioms
\begin{alignat*}{2}
	& \axAP && \quad \sqex{M_\sigma}\pi \iff (pre(\sigma) \implies \pi) \text{ for $\pi \in \langProp$}\\
	& \axAN && \quad \sqex{M_\sigma} \neg \phi \iff (pre(\sigma) \implies \neg \sqex{M_\sigma} \phi)\\
	& \axAC && \quad \sqex{M_\sigma}(\phi \land \psi) \iff (\sqex{M_\sigma}\phi \land \sqex{M_\sigma}\psi\\
	& \axAK && \quad \sqex{M_\sigma}\Box_a\phi \iff (pre(\sigma) \implies \bigwedge_{v \in \sigma R_a}
		\Box_a \sqex{M_v} \phi) \\
	& \axAU && \quad \sqex{M_T} \phi \iff \bigwedge_{u \in T} \sqex{M_u} \phi
\end{alignat*}
and the rule
\[
	\axNecA \quad \text{From $\vdash \phi$ infer $\vdash \sqex{M_\sigma} \phi$}
\]
\end{defn}

\begin{lemma} \label{axiomAMLSoundComplete}
The axiomatisation \AXAML is sound and complete with respect to the logic $\langActEx$.
\end{lemma}

\begin{defn} \label{axiomRML}
The axiomatisation \AXRML contains the axioms and rules from \AXK, as well as the following axioms
\begin{alignat*}{2}
	& \axR && \quad \forall_B (\phi \implies \psi) \implies (\forall_B \phi \implies \forall_B \psi) \\
	& \axRP && \quad \forall_B \pi \iff \pi \text{ where } \pi \in \langProp \\
	& \axRK && \quad\exists_B \cover_a \Gamma_a \iff \bigwedge_{\gamma \in \Gamma} \Diamond_a \exists_B
	\gamma \text{ where } a \in B \\
	& \axRComm && \quad \exists_B \cover_a \Gamma_a \iff \cover_a \{ \exists_B \gamma | \gamma \in
	\Gamma_a\} \text{ where } a \notin B\\
	& \axRDist && \quad \exists_B \bigwedge_{c \in C} \cover_c \Gamma_c \iff \bigwedge_{c \in C}
	\exists_B \cover_c \Gamma_c \text{ where } C \subseteq A
\end{alignat*}
and the rule
\[
	\axNecR \quad \text{From $\vdash \phi$, infer $\vdash \forall_B \phi$}
\]
\end{defn}

\begin{lemma} \label{axiomRMLSoundComplete}
The axiomatisation \AXRML is sound and complete with respect to the logic $\langRefine$.
\end{lemma}

\begin{defn} \label{axiomAAML}
The axiomatisation \AXAAML contains the axioms and rules from \AXRML and \AXAML.
\end{defn}

\begin{thm} \label{axiomAAMLSoundComplete}
The axiomatisation \AXAAML is sound and complete with respect to the logic $\langArbAct$.
\end{thm}

\section{Multi-agent epistemic goal achievement in $\langArbAct$}

In this chapter, we examine an algebra for constructing event models that will, if possible, achieve
epistemic goals or cause a model to crash in the process.
We examine this goal achievement for a subset of agents $B \subseteq A$.\\
\\
%\FIXME: citations here
In \FIXME, Hales demonstrates that it is possible to determine whether an
finite epistemic goal can be achieved.
Furthermore, if it is achievable Hales constructs event models that will realise
that goal.
We will focus on defining a framework that constructs these event models in a
recursive manner.
This facilitates an automated method for updating knowledge models to reflect a
knowledge state.

\subsection{Technical preliminaries}

The event models that Hales employs resemble finite trees.
We give a rigourous definition for them as follows

\begin{defn} \label{finTree}
Let $M = (\Sigma, R, pre, r)$ be a pointed event model.
$M$ is a finite tree event model if
\begin{itemize}
	\item $\Sigma$, the set of action points is finite
	\item $r$ is the root of the tree and is not accessible from any other action point
	\item for each $s \in \Sigma \setminus \{ r \}$ there is a unique agent $a \in A$ and a unique
	action $p \in \Sigma$ such that $(p,s) \in R(a)$
	\item for each $s \in \Sigma$ there exists a unique sequence of actions in $\Sigma$, $r = s_0,
	s_1, \ldots, s_n = s$ and a sequence of agents $a_1, a_2, \ldots, a_n$ such that $s_0 R_{a_1}
	s_1$, $s_1 R_{a_2} s_2$, $\ldots, s_{n-1} R_{a_n} s_n$
\end{itemize}
\end{defn}

We say that the class of finite tree event models is $\treeClass$.

\begin{defn} \label{forest}
Let $M_T = (\Sigma, R, pre, T)$ be a multi-pointed event model.
$M_T$ is a finite forest event model if
\begin{itemize}
	\item each point $t$ in $T$ is the root of a finite tree event model $M^t = (\Sigma^t, R^t,
	pre^t, t)$
  \item $\Sigma = \bigcup_{t \in T} \Sigma^t$
	\item for each $\sigma \in \Sigma^t$, $pre(\sigma) = pre^t(\sigma)$
	\item if $s, t \in T$ such that $s \neq t$, then $\Sigma^s$ and $\Sigma^t$ are disjoint
  \item for each $a \in A \implies R_a = \bigcup_{t \in T} R_a^t$
\end{itemize}
\end{defn}

We say that the class of finite forest event models is $\forestClass$.

\begin{lemma} \label{treeIsForest}
The event model class $\treeClass$ is contained within the event model class
$\forestClass$, that is $\treeClass \subseteq \forestClass$.
\end{lemma}

It is clear that by our earlier definitions, a finite tree event model is also a finite forest event
model.

\begin{defn} \label{subtree}
Let $M = (\Sigma, R, pre, T)$ be a finite forest event model.
We say the pointed event model $M' = (\Sigma', R', pre', r')$ is a subtree of $M$ if
\begin{itemize}
	\item $\Sigma' \subseteq \Sigma$
	\item $\forall a \in A \implies R_a' \subseteq R_a$
	\item $\forall \sigma \in \Sigma' \implies pre(\sigma) = pre'(\sigma) $
	\item $M'$ is $R$-generable
	\item $M'$ is a finite tree event model
\end{itemize}
\end{defn}

\begin{defn} \label{leaf}
Let $M = (\Sigma, R, pre, r)$ be a finite tree event model.
Let $M' = (\Sigma', R', pre', r')$ be a subtree of $M$.
$M'$ is a leaf node of $M$ if $\forall a \in A \implies R'_a = \varnothing$ and $\Sigma' = \{ r'\}$.
\end{defn}

In order to generate these models, we must construct an algebra that can construct event models.
However, we are unaware of any operations that are appropriate for building tree models.
We define an operation to describe a group of agents' belief with regards to the possible execution
of one event model instead of another.

\begin{defn} \label{considers}
Let $M^1$ and $M^2$ be multi-pointed event models, and without loss of
generality let $M^1$ and $M^2$ be disjoint.
Let $B$ be a subset of agents participating in $M^1$ or $M^2$.
We define $M = M^1 \to_B M^2$ as 
\begin{itemize}
  \item $\Sigma = \Sigma^1 \cup \Sigma^2$
  \item $R_a = R^1_a \cup R^2_a \text{if } a \notin B$
	\item $R_a =
      R^1_a \cup
      R^2_a \cup
      \{(s,t) | s \in T^1 \land t \in T^2 \}
    \text{if } a \in B $
  \item $pre = pre^1 \cup pre^2$
  \item $T = T^1$
\end{itemize}
The $\to$ operator will be referred to as ``considers".
\end{defn}

$M^1 \to_B M^2$ indicates that if $M^1$ was executed, an agent in $B$ considers $M^2$ as another
possible update.
In the case that $B = A$, we will denote this by $\to$, and if $B = \{a\}$, then
we will write $\to_a$.
We also present the disjoint union operator defined by \FIXME.

%\FIXME: who introduced this? (Baltag and Moss)

\begin{defn} \label{disjoint}
Let $M^1$ and $M^2$ be multi-pointed event models, and without loss of generality let $M^1$ and
$M^2$ be disjoint.
We define $M = M^1 \sqcup M^2$ as
\begin{itemize}
	\item $\Sigma = \Sigma^1 \cup \Sigma^2$
	\item $R_a = R^1_a \cup R^2_a$
	\item $pre = pre^1 \cup pre^2$
	\item $T = T^1 \cup T^2$
\end{itemize}
\end{defn}
This is the disjoint union of the two event models, which we can refer to as the agents in $A$
knowing that one of the two models has occurred.
Baltag and Moss call this a non-deterministic choice.
%\FIXME: cite

\begin{lemma} \label{disjForestIsForest}
Let $M^1_{T^1}, M^2_{T^2} \in \forestClass$ be two disjoint forest event models.
Then $M_T = M^1_{T^1} \sqcup M^2_{T^2} \in \forestClass$.
\end{lemma}

\begin{proof}
We must show each of the following
\begin{enumerate}
	\item each $t \in T$ corresponds to a finite tree event model $M^t \in \treeClass$ \label{treeCorrespondence}
	\item for each $M^t$, $\Sigma^t \subseteq \Sigma$ \label{forestStateSubsets}
	\item for each $M^t$, $R^t \subseteq R$ \label{forestEdgeSubsets}
	\item for each $M^t$, for each $s \in \Sigma^t$, $pre^t(s) = pre(s)$ \label{preconMatch}
	\item for each $s, t \in T$, $\Sigma^s$ and $\Sigma^t$ are disjoint \label{subtreeStatesDisjoint}
\end{enumerate}

We note that $T = T^1 \sqcup T^2$.
Thus $t \in T \implies (t \in T^1 \lor t \in T^2)$.
Since $M^1_{T^1}$ and $M^2_{T^2}$ are both finite forest event models then there must be some
subtree event model $M^t \in \treeClass$ that corresponds to $t$.
Without loss of generality, let $t \in T^1$.\\
\\
Furthermore, by the definition of $\sqcup$ (Definition \ref{disjoint}), for any $M^t$, $\Sigma^t \subseteq \Sigma^1 \subseteq \Sigma$.
Also, $R^t \subseteq R^1 \subseteq R$ and for all $s \in \Sigma^1 \implies pre^t(s) = pre^1(s) =
pre(s)$.
Finally, if $t, t' \in T$, each $M^t$ is disjoint from any other $M^{t'}$ since
\begin{itemize}
	\item $t' \in T^1 \implies$ that condition \ref{subtreeStatesDisjoint} previously held for
	$M^1_{T^1} \in \forestClass$ and thus $\Sigma^{t'}$ is disjoint $\Sigma^t$
	\item $t' \in T^2$ will ensure that $\Sigma^{t'}$ and $\Sigma^t$ are disjoint by the premise of
	the lemma
\end{itemize}
\end{proof}

A final miscellaneous result shown by Hales in \FIXME, which we employ later, is reproduced here.

\begin{lemma} \label{brestrictDisjoint}
Suppose $\{ M^i_{T^i} = (\Sigma^i, R^i, pre^i, T^i) | i \in [1, n] \}$ is a finite set of $n$ event
models.
Furthermore, let each $M^i_{T^i} \in \eventClass_B$.
Then
\[
	M_T = \bigsqcup_{i = 1}^{n} M^i_{T^i} \in \eventClass_B
\]
\end{lemma}

\begin{proof}
We will inductively show that for $k$ event models
\[
	\bigsqcup_{i = 1}^k M^i_{T^i} \in \eventClass_B
\]
We begin with our base case, where $k = 1$.
This is trivially so by the definition of $M^1_{T^1}$.
\[
	\bigsqcup_{i = 1}^1 M^i_{T^i} = M^1_{T^1} \in \eventClass_B
\]
Now, suppose that our induction hypothesis holds for $k$ event models.
Let $M^K_{T^K} = \bigsqcup_{i = 1}^k M^i_{T^i} \in \eventClass_B$.
Then for $k+1$ event models, let
\begin{align*}
	M'_{T'} = & \bigsqcup_{i = 1}^{k+1} M^i_{T^i} \\
	= & \bigsqcup_{i = 1}^k M^i_{T^i} \sqcup M^{k+1}_{T^{k+1}} \\
	= & M^K_{T^K} \sqcup M^{k+1}_{T^{k+1}}
\end{align*}
We note that since $M'_{T'}$ is a disjoint union of event models, $M'_{T^i} \sim M^i_{T^i}$ is a
trivial bisimilarity.
Similarly, $M'_{T^K} \sim M^K_{T^K}$ is a trivial bisimilarity.\\
\\
Let $\gamma$ be either of $K$ or $k+1$, and suppose $\sigma \in \Sigma^\gamma$.
Let $N_s \in \kripkeClass$.
As $M^\gamma \in \eventClass_B$, then $N_s \otimes M^\gamma_\sigma \lesssim_B N_s$.
We note that due to $M'$ being a disjoint union of event models, $M'_\sigma \sim M^\gamma_\sigma$.
Then from Lemma \ref{eventModelEquivalent} we have that $N_s \otimes M^\gamma_\sigma \sim N_s
\otimes M'_\sigma$.
From Lemma \ref{bisimilarIsRefinement}, we have $N_s \otimes M'_\sigma \lesssim_B N_s \otimes M^\gamma_\sigma$.
From Lemma \ref{refinementPreorder}, $\lesssim_B$ is a transitive relation.
Then $N_s \otimes M'_\sigma \lesssim_B N_s$.
Thus
\[
M'_{T'} = \bigsqcup_{i = 1}^{k+1} M^i_{T^i} \in \eventClass_B.
\]
\end{proof}

We can use the operations $\to$ (considers) and $\sqcup$ (choice) to construct finite tree and
forest event models, as we show in the next section.

\subsection{Completeness}

\begin{lemma} \label{finTreeConstruct}
Suppose $M = (\Sigma, R, pre, r)$ is a finite tree event model.
$M$ can be constructed using insanity event models and $\to$.
\end{lemma}
\begin{proof}
Let $M' = (\Sigma', R', pre', r')$ be a subtree of $M$.
We will show by induction that for any $M'$ we can use insanity event models and $\to$ to
construct $M'$.\\
\\
Suppose that $M' = (\Sigma', R', pre', r')$ is a leaf node.
Let $pre'(r') = \phi$, a formula in our logical language.
$M'$ is an insanity event model by definition.
Thus, we can construct $M'$ using insanity event models when $M'$ is a leaf node of $M$.\\
\\
Let $M' = (\Sigma', R', pre', r')$ be an arbitrary subtree of $M$.
Suppose $pre'(r') = \phi$, where $\phi$ is a formula in our logical language.
Let $M^1, M^2, \ldots, M^n$ be all the disjoint subtrees of $M'$.
Suppose that each of $M^1, M^2, \ldots, M^n$ fulfill the induction hypothesis.
Furthermore, let there be agents $a_1, a_2, \ldots, a_n$ such that $r' R_{a_1} r^1$, $r' R_{a_2} r^2,
	\ldots, r' R_{a_n} r^n$.\\
\\
Consider the $M^t = (\{ t \}, R^t, pre^t, t) \in \insaneClass$.
Let $pre^t(t) = \phi$.
Consider the event model 
\[
M^K = (\ldots((M^t \to_{a_1} M ^ 1) \to_{a_2} M_2) \to_{a_3} \ldots
\to_{a_{n-1}} M^{n-1} ) \to_{a_n} M ^ n
\]
We will show that $M^K$ and $M'$ are equivalent event models.\\
\\
Each of $M^1, M^2, \ldots, M^n$ are subtrees of $M'$.
The action points, accessibilities and preconditions in each of $M^1, M^2, \ldots, M^n$ are
equivalent to the action points and the accessibilities and preconditions of those points in $M'$.
We can see that by its definition the ``root" of $M^K$, $t$ has the same precondition as $r'$.
Furthermore, both $r'$ and $t$ can access each of $M^1, M^2, \ldots M^n$ by an $a_1, a_2, \ldots, a_n$ edge
respectively.\\
\\
Thus $M'$ and $M^K$ are equivalent.
We can form $M'$ using insanity event models and $\to$, and thus any arbitrary subtree of $M'$
fulfills the induction hypothesis.
\end{proof}

\begin{lemma} \label{forestCon}
Let $M = (\Sigma, R, pre, T)$ be a finite forest event model.
Then $M$ can be constructed using $\to$, $\sqcup$ and insanity event models.
\end{lemma}

\begin{proof}
Let $M^t = (\Sigma^t, R^t, pre^t, t) \in \treeClass$ be the
subtree of $M$ that corresponds to point $t \in T$ (Definition \ref{forest}).
By Lemma \ref{finTreeConstruct} we can generate from $\insaneClass$ and $\to$.
By Lemma \ref{treeIsForest} $M^t \in \forestClass$.
Then by a recursive and finite number of applications of Lemma
\ref{disjForestIsForest} we have that $\bigsqcup_{t \in T} M^t$ is a finite
forest event model.
\end{proof}

\begin{corr} \label{forestConCorr}
Let $M = (\Sigma, R, pre, T)$ be a finite forest event model, and for each $t \in T$ let $M^t \in
\treeClass$ be the subtree of $M$ corresponding to $t$.
Then $M = \bigsqcup_{t \in T} M^t$.
\end{corr}

\subsection{Achieving information goals}

%\FIXME: Needs to cite James

%\begin{lemma} \label{coverFormulaAchievementK}
%Let $B, C \subseteq A$ and
%\[
%\phi = \pi \land \bigwedge_{c \in C} \cover_c \Gamma_c \in \langArbAct
%\]
%where $\Gamma$ is a finite set.
%Suppose that for each $c \in C$, and for each $\gamma \in \Gamma_c$ there is an event model
%$M^\gamma_T \in \forestClass$ and $M^\gamma_T \in \eventClass_B$  such that
%$\vdash \sqex{M^\gamma_{T^\gamma}} \gamma$ and $\vdash \anex{ M^\gamma_{T^\gamma} } \gamma \iff
%\exists_B \gamma$.
%Then there exists a finite forest event model $M_T \in \forestClass$ and $M_T \in \eventClass_B$
%such that $\vdash \sqex{M_T}\phi$ and $\vdash \anex{ M_T } \phi \iff \exists_B \phi$.
%\end{lemma}
%
%\begin{proof}
%Let us say that $A$, a finite set of agents can be enumerated as $A = \{ a_1, a_2, \ldots, a_n\}$
%and that the set $A \setminus C = \{d_1, d_2, \ldots, d_k\}$.
%For each $a \in A$, if $a \in C$,
%\[
%	M^a_{T^a} = \bigsqcup_{\gamma \in \Gamma_a} M^\gamma_{T^\gamma}
%\]
%By Lemma \ref{disjForestIsForest} $M_c \in \forestClass$.
%Furthermore, by Lemma \ref{brestrictDisjoint}, $M_c \in \eventClass_B$.\\
%\\
%If $a \notin C$ then let (\FIXME plz)
%\[
%	M^a_{T^a} = (\{\sigma\}, \varnothing, \{(\sigma, \top)\}, \{\sigma\}) \in \insaneClass.
%\]
%Consider the insanity model $M'_\sigma \in \insaneClass$ such that $pre(\sigma) =
%\exists_B \phi$.
%Let
%\[
%M_T = ((\ldots((M'_\sigma \to_{a_1} M^{a_1}_{T^{a_1}}) \to_{a_2} M^{c_2}_{T^{a_2}}) \to_{a_3} \ldots )
%		\to_{a_n} M^{a_n}_{T^{a_n}}).
%\]
%Our proof is decomposed into four parts.
%Firstly, we show that $M_T \in \treeClass$ and therefore implicitly $M_T \in \forestClass$.
%model.
%Secondly, we show that $\vdash \sqex{M_T} \phi$.
%Thirdly, we show $\vdash \anex{ M_T } \phi \iff \exists_B \phi$.
%Lastly, we show that $M_T \in \eventClass_B$.\\
%\\
%According to Definition \ref{finTree} $M_T = (\Sigma, R, pre, T)$ is a finite tree event model if
%and only if the following four conditions must hold:
%\begin{enumerate}
%	\item $\Sigma$ is finite \label{treeConFinite}
%	\item $T = \{\sigma\}$, where $R \sigma = \varnothing$ \label{treeConRoot}
%	\item for each $s \in \Sigma \setminus T$ there is only one $a \in A$ and only one $p \in \Sigma$
%	such that $p R_a s$ \label{treeConOneAgent}
%	\item for each $s \in \Sigma$ there is a unique finite sequence of points in $\Sigma$, $\sigma =
%	s_0, s_1, s_2, \ldots, s_k = s$ and a sequence of agents $a_1, a_2, \ldots, a_k$ such that $s_0
%	R_{a_1} s_1, s_1 R_{a_2} s_2, \ldots, a_{k-1} R_k
%	a_k$ \label{treeConUniquePath}
%\end{enumerate}
%
%We note that condition \ref{treeConFinite} is satisfied by the definition of $M_T$ as
%\[
%  \Sigma = \{\sigma\} \bigcup_{a \in A} (\bigcup_{\gamma \in \Gamma}
%      \Sigma^{\gamma})
%\]
%where $\Gamma$ is a finite set and each $\Sigma^\gamma$ is finite.
%Therefore, $\Sigma$ itself must also be finite.\\
%\\
%Condition \ref{treeConRoot} is satisfied by the definition of $M_T$ and the definition of $\to$
%(Definition \ref{considers}).
%$\to$ only adds relations to $\sigma R$, and $R \sigma$ begins as $\varnothing$.
%Thus $\sigma$ is not accessible from any other points.\\
%\\
%We next show \ref{treeConOneAgent} is satisfied.
%To do so we much show that for each $s$ in $\Sigma \setminus T = \Sigma \setminus \{ \sigma \}$, there
%is a unique $p \in \Sigma$ and $a \in A$ such that $p R_a s$.
%Suppose that there is some $a \in A$ such that $s \in \Sigma^a$.
%If $s \in T^a$, then $R_a s = \{ \sigma \}$ by the definition of $M_T$.
%Otherwise, by the definition of $M^a$, any $s \notin T^a$ is in some subforest of $M^a$
%and therefore there is a unique $p \in \Sigma^a$ and a unique agent $a' \in A$ such that $p R_{a'}
%s$.\\
%\\
%Lastly, we show that \ref{treeConUniquePath} holds.
%Suppose $s = \sigma$; the sequence of action points is of length 0 and thus no agents are involved.
%Now, suppose $s \in \Sigma \setminus \{ \sigma \}$.
%Then for some $a \in A$ we have $s \in \Sigma^a$.
%Then for some $s' \in T^a$ there is a unique sequence of agents $a_1, a_2, \ldots, a_n$ and action
%points $s' = s_0, s_1, s_2, \ldots, s_n = s$ such that $s_i R_{a_{i+1}} s_{i+1}$ for any $0 \leq i
%\leq n-1$.
%Furthermore, $\sigma R_a s'$ by the definition of $M_T$, so we can combine the previous statement
%with $\sigma R_a s'$ to say that there is a unique sequence of agents and points from $\sigma$ to
%$s$.
%Thus, $M_T \in \treeClass \implies M_T \in \forestClass$ by Lemma \ref{treeIsForest}.\\
%\\
%Next, we shall show that $\vdash \sqex{M_T} \phi$.
%We will show that each of the following holds
%\begin{enumerate}
%	\item $\vdash \sqex{M_T} \pi$
%	\item $\vdash \sqex{M_T} \Box_c \bigwedge_{\gamma \in \Gamma_c} \gamma$ for every $c \in C$
%	\item $\vdash \sqex{M_T} \bigvee_{\gamma \in \Gamma_c} \Diamond_c \gamma$ for every $c \in C$
%\end{enumerate}
%
%Firstly we show $\vdash \sqex{M_T} \pi$.
%\begin{align}
%	& \vdash \phi \implies \pi \label{cfa_c1_1} \\
%	& \vdash \neg \pi \implies \neg \phi \label{cfa_c1_2}\\
%	& \vdash \forall (\neg \pi \implies \neg \phi) \label{cfa_c1_3}\\
%	& \vdash \forall \neg \pi \implies \forall \neg \phi \label{cfa_c1_4}\\
%	& \vdash \neg \forall \neg \phi \implies \neg \forall \neg \pi \label{cfa_c1_5}\\
%	& \vdash \exists \phi \implies \exists_B \pi \label{cfa_c1_6}\\
%	& \vdash pre(\sigma) \implies \pi \label{cfa_c1_7}\\
%	& \vdash \sqex{M_\sigma} \pi \label{cfa_c1_8}
%\end{align}
%(\ref{cfa_c1_3}) follows from \axNecR, (\ref{cfa_c1_4}) follows from \axR, (\ref{cfa_c1_6}) follows from
%$\exists$, (\ref{cfa_c1_7}) follows from the definition of $M$ (as $pre(\sigma) = \exists \phi$) and
%(\ref{cfa_c1_8}) follows from \axAP.\\
%\\
%Now we suppose $c \in C$ and show $\vdash \sqex{M_T} \Box_c \bigwedge_{\gamma \in \Gamma} \gamma$.
%\begin{align}
%	& \vdash \sqex{M^{\gamma}_{T^{\gamma}}} \gamma \text{ for every }\gamma \in \Gamma^c
%	\label{cfa_c2_1} \\
%	& \vdash \bigwedge_{v \in T^\gamma} \sqex{M^\gamma_v} \gamma \text{ for every }\gamma \in \Gamma^c \label{cfa_c2_2} \\
%	& \vdash \Box \bigwedge_{v \in T^\gamma} \sqex{M^\gamma_v} \gamma \text{ for every } \gamma \in
%	\Gamma^c\label{cfa_c2_3} \\
%	& \vdash \bigwedge_{v \in T^\gamma} \Box_c \sqex{M^\gamma_v} \gamma \text{ for every } \gamma \in
%	\Gamma^c\label{cfa_c2_4} \\
%	& \vdash \bigwedge_{\gamma \in \Gamma^c} \bigwedge_{v \in T^\gamma} \Box_c \sqex{M^\gamma_v} \gamma\label{cfa_c2_5} \\
%	& \vdash \bigwedge_{\gamma \in \Gamma^c} \bigwedge_{v \in T^\gamma} \Box_c \sqex{M^\gamma_v}
%	\bigvee_{\gamma' \in \Gamma^c} \gamma'\label{cfa_c2_6} \\
%	& \vdash \bigwedge_{v \in \sigma R} \Box_c \sqex{M_v}\bigvee_{\gamma' \in \Gamma^c} \gamma'\label{cfa_c2_7} \\
%	& \vdash pre(\sigma) \implies \bigwedge_{v \in \sigma R} \Box \sqex{M_v} \bigvee_{\gamma' \in
%		\Gamma^c} \gamma'\label{cfa_c2_8} \\
%	& \vdash \sqex{M_\sigma} \Box_c \bigvee_{\gamma' \in \Gamma^c} \gamma'\label{cfa_c2_9} 
%\end{align}
%(\ref{cfa_c2_1}) follows from our hypothesis, (\ref{cfa_c2_2}) follows from \axAU, and (\ref{cfa_c2_8})
%	follows from \axAK.\\
%\\
%Finally, let $c \in C$. We then show $\vdash \sqex{M_\sigma}\bigwedge_{\gamma \in \Gamma^c}
%\Diamond_c \gamma$.\\
%\\
%Suppose that $c \in B$.
%Then
%\begin{align}
%	& \vdash \exists_B \phi \implies \exists_B \cover_c \Gamma_c \label{cfa_c3_1a}\\
%	& \vdash \exists_B \phi \implies \bigwedge_{\gamma \in \Gamma} \Diamond \exists_B
%	\gamma\label{cfa_c3_2a}
%\end{align}
%(\ref{cfa_c3_1a}) follows from similiar reasoning for (\ref{cfa_c1_1} - \ref{cfa_c1_6}) and
%(\ref{cfa_c3_2a}) follows from \axRK.\\
%\\
%Now suppose $c \notin B$.
%Then
%\begin{align}
%	& \vdash \exists_B \phi \implies \exists_B \cover_c \Gamma_c \label{cfa_c3_1b}\\
%	& \vdash \exists_B \phi \implies \cover_c \{\exists_B \gamma | \gamma \in \Gamma_c \}a
%	\label{cfa_c3_2b}\\
%	& \vdash \exists_B \phi \implies \bigwedge_{\gamma \in \Gamma} \Diamond_c \exists_B \gamma
%	\label{cfa_c3_3b}
%\end{align}
%(\ref{cfa_c3_1b}) follows from similiar reasoning for (\ref{cfa_c1_1} - \ref{cfa_c1_6}).
%(\ref{cfa_c3_2b}) follows from \axRComm.
%(\ref{cfa_c3_3b}) follows from the definition of the cover operator (Definition \ref{coverDef}).\\
%\\
%Thus for any $c \in C$ we have that $\vdash \exists_B \phi \implies \bigwedge_{\gamma \in \Gamma}
%\Diamond_c \exists_B \gamma$.
%Then for any $c \in C$
%\begin{align}
%	& \vdash \exists_B \phi \implies \bigwedge_{\gamma \in \Gamma} \Diamond_c \anex{
%	M^\gamma_{T^{\gamma}} } \gamma\label{cfa_c3_3}\\
%	& \vdash \exists_B \phi \implies \bigwedge_{\gamma \in \Gamma} \Diamond_c \anex{
%	\bigvee_{v \in T^\gamma} M^\gamma_{v} } \gamma\label{cfa_c3_4}\\
%	& \vdash \exists_B \phi \implies \bigwedge_{\gamma \in \Gamma} \Diamond_c \anex{
%	\bigvee_{v \in \sigma R} M^\gamma_{v} } \gamma\label{cfa_c3_5}\\
%	& \vdash \bigwedge_{\gamma \in \Gamma} (\exists_B \phi \implies \bigvee_{v \in \sigma R_c}
%	\Diamond_c \anex{ M^\gamma_{v} } \gamma)\label{cfa_c3_6}\\
%	& \vdash \bigwedge_{\gamma \in \Gamma} (\exists_B \phi \implies \anex{ M^\gamma_{\sigma}
%	} \Diamond_c \gamma)\label{cfa_c3_7}\\
%	& \vdash \bigwedge_{\gamma \in \Gamma} ([M^\gamma_{\sigma}] \Diamond_c \gamma)\label{cfa_c3_8}
%\end{align}
%We have (\ref{cfa_c3_3}) follows from (\ref{cfa_c3_3b}) and (\ref{cfa_c3_2a}).
%Then (\ref{cfa_c3_4}) follows from hypothesis, (\ref{cfa_c3_5}) from \axAU, (\ref{cfa_c3_6}) and
%(\ref{cfa_c3_7}) from the definition of $M$ and (\ref{cfa_c3_8}) from \axAK.\\
%\\
%Together, we combine our result to show
%\begin{align}
%	& \vdash \sqex{M_\sigma} (\pi \land \bigwedge_{c \in C} \left( \sqex{M_\sigma} \Box_c \bigvee_{\gamma \in
%		\Gamma^c} \gamma \land
%	\bigwedge_{\gamma \in \Gamma^c} \sqex{M_\sigma} \Diamond_c \gamma \right) \label{cfa_cc_1} \\
%	& \vdash \sqex{M_\sigma}(\pi \land \bigwedge_{c \in C} \cover_c \Gamma_c) \label{cfa_cc_2}
%\end{align}
%(\ref{cfa_cc_1}) follows from (\ref{cfa_c1_8}), (\ref{cfa_c2_7}) and (\ref{cfa_c3_8}) and
%(\ref{cfa_cc_2}) follows from \axAC.\\
%\\
%Next, we show that $\vdash \anex{ M_T } \phi \iff \exists \phi$.
%\begin{align}
%	& \vdash \anex{ M_\sigma } \phi \iff (pre(\sigma) \land [ M_\sigma ] \phi \label{cfa_cc1_1}\\
%	& \vdash \anex{ M_\sigma } \phi \iff pre(\sigma) \label{cfa_cc1_2}\\
%	& \vdash \anex{ M_\sigma } \phi \iff \exists \phi\label{cfa_cc1_3}
%\end{align}
%(\ref{cfa_cc1_1}) follows from a simple semantic argument, (\ref{cfa_cc1_2}) follows from
%(\ref{cfa_cc_2}) and (\ref{cfa_cc1_3}) follows from the definition of $M$.\\
%\\
%Lastly, we show that $M_\sigma \in \eventClass_B$.
%\end{proof}
%
%\begin{lemma} \label{disjunctionFormulaAchievementK}
%Let $\phi = \alpha \lor \beta \in \langArbAct$ and $B \subseteq A$.
%Suppose that for $\gamma \in \{\alpha, \beta\}$ there is a finite forest event model
%$M^\gamma_{T^\gamma} \in \forestClass$ and $M^\gamma_{T^\gamma} \in \eventClass_B$ such that
%$\vdash \sqex{M^\gamma_{T^\gamma}} \gamma$
%and $\vdash \anex{ M^\gamma_{T^\gamma} } \gamma \iff \exists \gamma$.
%Then there exists a finite forest event model $M_T \in \forestClass$ and $M_T \in \eventClass_B$
%such that $\vdash \sqex{M_T}\phi$ and $\vdash \anex{ M_T } \phi \iff \exists_B \phi$.
%\end{lemma}
%
%\begin{proof}
%Let $M_T = M^\alpha_{T^\alpha} \sqcup M^\beta_{T\beta}$.
%We will show three things.
%Firstly, that $M_T$ is a finite forest event model.
%Secondly, that $\vdash \sqex{M_T}\phi$.
%Lastly, we show $\vdash \anex{ M_T } \phi \iff \exists \phi$.
%We assume, without loss of generality, that $\Sigma^\alpha$ and $\Sigma^\beta$ are disjoint.\\
%\\
%To show that $M_T$ is a finite forest event model, we observe that $M_T$ is a disjoint union of two
%finite forest event models who are both disjoint.
%Then by Lemma \ref{disjForestIsForest} $M_T$ is a finite forest event model.
%Note that each action point in $M_T$ is bisimilar to a corresponding point in $M^\alpha_{T^\alpha}$ or
%$M^\beta_{T^\beta}$.\\
%\\
%Next, we show that $\vdash \sqex{M_T}\phi$.
%\begin{align}
%	&\vdash \sqex{M^\alpha_{T^\alpha}}\alpha \land \sqex{M^\beta_{T^\beta}}\beta \label{djfa_c1_1}\\
%	&\vdash \sqex{M_{T^\alpha}}\alpha \land \sqex{M_{T^\beta}}\beta \label{djfa_c1_2}\\
%	&\vdash \sqex{M_{T^\alpha}}(\alpha \lor \beta) \land \sqex{M_{T^\beta}}(\alpha \lor \beta) \label{djfa_c1_3} \\
%	&\vdash \sqex{M_T}(\alpha \lor \beta) \label{djfa_c1_4}
%\end{align}
%(\ref{djfa_c1_1}) follows from our hypothesis, (\ref{djfa_c1_2}) follows from Lemma \ref{eventModelEquivalent} and the fact that
%$M_{T^\alpha} \sim M^\alpha_{T^\alpha}$ and $M_{T^\beta} \sim M^\beta{T^\beta}$.
%(\ref{djfa_c1_3}) is a simple introduction of disjunctions and (\ref{djfa_c1_4}) follows from \axAU, as
%$T = T^\alpha \cup T^\beta$.\\
%\\
%Now we show that $M_T$ is a $B$-restricted event model.
%Since $M^\alpha, M^\beta \in \eventClass_B$, by Lemma \ref{brestrictDisjoint} $M_T \in
%\eventClass_B$.\\
%\\
%Finally, we show that $\anex{M_T} \iff \exists \phi$.
%\begin{align}
%	&\vdash \exists (\alpha \lor \beta) \implies (\exists \alpha \lor \exists \beta) \label{djfa_c2_1} \\
%	&\vdash \exists (\alpha \lor \beta) \implies (\anex{ M^\alpha_{T^\alpha} } \alpha \lor
%			\anex{ M^\beta_{T^\beta} }\beta) \label{djfa_c2_2}\\
%	&\vdash \exists (\alpha \lor \beta) \implies (\anex{M_{T^\alpha}} \alpha \lor \anex{M_{T^\beta}}
%			\beta)\label{djfa_c2_3}\\
%	&\vdash \exists (\alpha \lor \beta) \implies (\anex{M_{T^\alpha}} (\alpha \lor \beta) \lor \anex{M_{T^\beta}}
%			(\alpha \lor \beta))\label{djfa_c2_4}\\
%	&\vdash \exists (\alpha \lor \beta) \implies (\anex{M_T} (\alpha \lor \beta))\label{djfa_c2_5}
%\end{align}
%(\ref{djfa_c2_1}) follows from \axR, (\ref{djfa_c2_2}) follows from hypothesis and
%(\ref{djfa_c2_3}) follows from Lemma \ref{eventModelEquivalent} and $M_{T^\alpha} \sim M^\alpha_{T^\alpha}$ and $M_{T^\beta}
%\sim M^\beta_{T^\beta}$.
%(\ref{djfa_c2_4}) is a simple disjunction introduction, and (\ref{djfa_c2_5}) follows from \axAU.\\
%\\
%The converse, $\vdash \anex{M_T} \phi \implies \exists \phi$ follows from a semantic
%argument, from $M_T \in \eventClass_B$, from Lemma \ref{eventModelsRefine} and the completeness of \AXAAML.\\
%\end{proof}
%
%\begin{thm} \label{goalAchievementK}
%Let $\phi \in \langArbAct$ be a finite formula.
%Then there exists a finite forest event model $M_T \in \eventClass$ such that
%$\vdash \sqex{M_T}\phi$ and $\vdash \anex{ M_T } \phi \iff \exists \phi$.
%\end{thm}
%
%\begin{proof}
%Without loss of generality from Lemma {\FIXME} we may assume that $\phi \in \lang$, and from Lemma
%\ref{allInCoverNormal} we may further assume that $\phi$ is in cover disjunctive normal form.
%We proceed with an inductive case on the structure of $\phi$.\\
%\\
%Suppose that $\phi = \pi \land \cover \Gamma$ where $\pi \in \langProp$ and $\Gamma \subseteq \lang$
%is a finite set of formulae.
%From the induction hypothesis, for every $\gamma \in \Gamma$ there exists a finite forest event
%model $N^\gamma_{T^\gamma} \in \eventClass$ such that $\vdash \sqex{N^\gamma_{T^\gamma}} \gamma$ and
%$\vdash \anex{N^\gamma_{T^\gamma}} \gamma \iff \exists \gamma$.
%Then from Lemma \ref{coverFormulaAchievementK} there exists a finite forest event model $M_T$ such
%that $\vdash \sqex{M_T} \phi$ and $\vdash \anex{M_T} \phi \iff \exists \phi$.
%We note that the base case for the induction occurs when $\Gamma = \varnothing$ and thus $\phi =
%\pi$.\\
%\\
%Suppose that $\phi = \alpha \lor \beta$.
%Then from the induction hypothesis there exists finite forest event models $N^\alpha_{T^\alpha}$ and
%$N^\beta_{T^\beta} \in \eventClass$ such that for $\gamma \in \{\alpha, \beta\}:
%\vdash \sqex{N^\gamma_{T^\gamma}} \gamma \land \vdash \anex{N^\gamma_{T^\gamma}} \iff \exists
%\gamma$.
%Then from Lemma \ref{disjunctionFormulaAchievementK} there exists a finite forest event model $M_T$ such
%that $\vdash \sqex{M_T}$ and $\vdash \anex{M_T} \phi \iff \exists \phi$.
%\end{proof}

\begin{thm} \label{approximatingEventModel}
Let $M_T \in \eventClass$.
Then there is some $M'_{T'} \in \forestClass$ such that $M_T \sim_n M'_{T'}$.
\end{thm}

\begin{proof}
Without loss of generality, for each pair $t, t' \in T$, we say that they are
$n$-disjoint.
That is there is no sequence of $n$ action points $t = s_1, s_2, \ldots,
s_n = t'$ and agents $a_1, a_2, \ldots, a_{n-1}$ such that $s_1 R_{a_1} s_2,
    \ldots, s_{n-1} R_{a_{n-1}} s_n$.
We will show inductively that for any $n$, the following two conditions hold
\begin{itemize}
\item there is a forest event model $M'_{T'} \in \forestClass$ such that $M'_{T'} \sim_n M_T$
\item for each $t \in T$, there is a $t' \in T'$ and subtree of $M'_{T'}$, $M^{t'}_{t'}$ such that
$M'_{t'} \sim_n M_t$
\end{itemize}
Suppose $n = 0$ as our base case.
Let $t \in T$, and consider the insanity model $M'_{t} \in \insaneClass$ such that $pre'(t) \iff
pre(t)$.
By \FIXME $M'_{t} \in \treeClass$ and therefore by \FIXME $M'_{t} \in \forestClass$ also holds.
By the definition of $n$-bisimilarity (Definition \ref{nBisimEvent}), $M'_{t}
\sim_0 M_t$.
Now, let
\[
  M'_{T'} = \bigsqcup_{t' \in T} M'_{t} \in \forestClass
\]
By Lemma \ref{disjForestIsForest}, $M'_{T'} \in \forestClass$.
Furthermore, it is clear that each point $t \in T$ corresponds to some $t' \in T'$ such that $M_t
\sim_0 M'_{t'}$.
Lastly, since $M'_{T'}$ is the disjoint union of multiple finite tree event models, for $t, t' \in
T'$ we have that $\Sigma_t$ and $\Sigma_{t'}$ are disjoint.
Thus our induction hypothesis holds for $n = 0$.\\
\\
Now, suppose that the induction hypothesis holds for $n = k-1$ and let $n = k$.
Let $s \in T$ and $a \in A$.
By the induction hypothesis, for each $t \in s R_a$, we can construct $M^t_t \in \treeClass$ such that
$M^t_t \sim_{k-1} M_t$.
Consider $M^s_s \in \insaneClass \subseteq \forestClass$ such that $pre'(s) \iff
pre(s)$.
By the definition of $n$-bisimilarity (Definition \ref{nBisimEvent}), $M'_{s}
\sim_0 M_s$.\\
\\
Then, let
\[
  M'_{T'} = \bigsqcup_{s \in T} M^s_s \to_a (\bigsqcup_{t \in s R_a} M^t_{t})
\]
Our proof is decomposed into three parts.
First we show that $M'_{T'} \in \forestClass$.
Secondly, we show that for $t \in T$ there is a $t' \in T'$ such that the subtree $M^{t'}_{t'}$ of
$M'_{T'}$ such that $M^{t'}_{t'} \sim_n M_t$.
Lastly we show that $M'_{T'} \sim_k M_T$.\\
\\
To show that $M'_{T'} \in \forestClass$, the following four conditions must hold
\begin{enumerate}
	\item each point $t \in T'$ is the root of a finite tree event model $M^t_t = (\Sigma^t, R^t,
	pre^t, t)$ \label{forestConOne}
  \item $\Sigma' = \bigcup_{t \in T'} \Sigma^t$ \label{forestConTwo}
  \item for each $a \in A \implies R'_a = \bigcup_{t \in T'} R^t_a$ \label{forestConFive}
	\item for each $\sigma \in \Sigma^t$, $pre'(\sigma) = pre^t(\sigma)$ \label{forestConThree}
	\item if $s, t \in T'$ such that $s \neq t$, then $\Sigma^s$ and $\Sigma^t$ are disjoint
	\label{forestConFour}
\end{enumerate}

To show that \ref{forestConOne} holds, suppose $t \in T'$.
We must show that $M'_t \in \treeClass$.
We observe that $\Sigma'$, the set of action points is finite, since it is the finite union of a set
of finite forest event models which in turn have finite sets of points. This follows from the
definition of $M'_{T'}$.\\
\\
Next, $t$ is the root of the tree and is not accessible from any other action point, which follows
from the definition of $M'_{T'}$ being a disjoint union of multiple models, and relations only
being added to $t R_a$ and none added to $R_a t$ for any $a \in A$.\\
\\
Suppose $s \in \Sigma' \setminus \{ t \}$.
Then there is an agent $a \in A$ and $s' \in t R'_a$ such that $s$ is an action point in
$\Sigma^{s'}_{s'}$, the set of action points for the subtree $M^{s'}_{s'}$ of $M'_t$ with its root at
$s'$.\\
\\
Suppose $s = s'$.
Then the $R'_a s = \{ t \}$, and for any other $a'$, $R'_{a'} s = \varnothing$.\\
\\
Suppose $s \neq s'$.
Since $M^{s'}_{s'} \in \treeClass$ by the definition of a finite tree event model (Definition \ref{finTree}) we have that there is some
$p \in \Sigma^{s'}$ and $a' \in A$ such that $p R'_{a'} s$.\\
\\
Finally let $s \in \Sigma'_t$.
We must show that there is a finite sequence of action points $t = s_0, s_1, s_2, \ldots, s_n = s
\in \Sigma'_t$ and agents $a_1, a_2, \ldots, a_n \in A$ such that $s_0 R_{a_1} s_1, \ldots, s_{n-1}
R_{a_n} s_n$.
If $s = t$ then there is a sequence of length 0 of such points.
Suppose $s \neq t$.
If so then there is some agent $a \in A$ and $s' \in t R'_a$ such that $s \in \Sigma^{s'}_{s'}$, the set
of action points for the subtree $M^{s'}_{s'}$ of $M'_t$ with its root at $s'$.\\
\\
Since $M^{s'}_{s'} \in \treeClass$ by the definition of a finite tree event model (Definition
\ref{finTree}) we have that there is some sequence of action points $s' = s_0, s_1, s_2, \ldots, s_n =
s \in \Sigma^{s'}_t$ and agents $a_1, a_2, \ldots, a_n \in A$ such that $s_0 R'_{a_1} s_1, \ldots,
s_{n-1} R'_{a_n} s_n$.
We already have shown that $R'_a s' = \{ t \}$.
Then there is a sequence $t R'_a s', s_0 R'_{a_1} s_1, \ldots, s_{n-1} R'_{a_n} s_n$.
Thus $M'_t \in \treeClass$ from Definition \ref{finTree} and as a result \ref{forestConOne} holds.\\
\\
Conditions \ref{forestConTwo}, \ref{forestConFive} and \ref{forestConThree} hold from the definition
of $\to$ (Definition \ref{considers}).
What remains is to show that \ref{forestConFour} holds.
Suppose that $s, t \in T'$ and $s \neq t$.
From hypothesis $\Sigma^s_s$ and $\Sigma^t_t$ are disjoint trees.
From the definition of $\to$ (Definition \ref{considers}) each of $\Sigma^s_s$ and $\Sigma^t_t$
remain disjoint.\\
\\
Next, we show that if $t \in T$ there is some $s \in T'$ and some subtree of $M'_{T'}$, $M^{s}_{s}$
such that $M^s_s \sim_k M_t$.
From the definition of $M'_{T'}$, there is a subtree of $M^s_s$, where $M^s_s \sim_0 M_t$.
Furthermore, by our induction hypothesis for each $a \in A$ and $t' \in t R_a$, there is an $a' \in
A$ and $s' \in s R_{a'}$ such that the subtree $M^{s'}_{s'}$ of $M^s_s$ is $k-1$-bisimilar to
$M_{t'}$.
This allows us to satisfy {\bf $k$-forth-$a$} and {\bf $k$-back-$a$} for every $a \in A$.
We now only need show that $M^s_s \sim_{k-1} M'_s$.
It is clear from a simple inductive argument that this holds, by virtue of each $M^{s'}_{s'}$ being
$k-2$-bisimilar to $M_{t'}$ (Lemma \FIXME).
Then $M^s_s \sim_k M_t$, where $s \in T'$ and $M^s_s$ a subtree of $M_{T'}$.\\
\\
Lastly, we show that $M'_{T'} \sim_k M_T$.
We have shown that for each $t \in T$, there is a $t' \in T'$ such that the subtree $M^{t'}_{t'}
\sim_k M_t$.
We observe from the definition of $M'_{T'}$ that it is the disjoint union of models subtrees that
are $k$-bisimilar to a model in $T$.
That is, any $t' \in T'$ is the root of a subtree $M^{t'}_{t'}$ of $M'_{T'}$ that is $k$-bisimilar
to $M_t$, for $t \in T$.
It is clear that as the finite disjoint union of $k$-bisimilar models, $M'_{T'}$ is itself $k$-bisimilar
to $M_T$.
Thus we have $M_T \sim_k M'_{T'}$ and our induction hypothesis holds for $n = k$.
\end{proof}

\begin{corr} \label{approximatingBRestricted}
Let $\phi \in \langArbAct$ and $B \subseteq A$.
Then there is some $M_T \in \forestClass$ such that $\sqex{M_T} \phi$ and
$\anex{M_T} \phi \iff \exists_B \phi$.
\end{corr}

\section{Multi-agent goal achievement in $\langArbAct$}

``Insanity models" are a somewhat cumbersome construct, since their only purpose
is to serve as nodes in the tree.
They have no meaning outside of a tree structure and their semantics are
unintuitive within the context of knowledge or belief.
It would thus be desirable to reduce our atomic models to only group
announcements, since public announcements have more meaning within the context of
knowledge.\\
\\
In order to do so, we must define an operation that ensures that if $M^1$ was to
be executed, a group of agents in $B$ would believe $M^2$ would be executed
instead.
%\FIXME: Add in the story/motivation --- why is this useful
\begin{defn} \label{believes}
Let $M^1$ and $M^2$ be multi-pointed event models, and without loss of
generality let $M^1$ and $M^2$ be disjoint.
Let $B$ be a subset of agents participant in $M^1$ or $M^2$.
We define $M = M^1 \mapsto_B M^2$ as 
\begin{itemize}
  \item $\Sigma = \Sigma^1 \cup \Sigma^2$
  \item $R_a =
    R^1_a \cup R^2_a \text{if } a \notin B$
	\item $\sim_a =
      R^1_a \setminus \{(s,t) | s \in T^1 \} \cup
      R^2_a \cup
      \{(s,t) | s \in T^1 \land t \in T^2 \}
    \text{if } a \in B$
  \item $pre = pre^1 \cup pre^2$
  \item $T = T^1$
\end{itemize}
We name this operation ``believes".
\end{defn}

Similarly to $\to$, in the case that $B = A$, we will denote this by $\mapsto$, and if $B = \{a\}$, then
we will write $\mapsto_a$.
The ``meaning" of $M^1 \mapsto_B M^2$ would be that given a set of actions in
$M^1$ the agents in $B$ believe that one of a set of actions in $M^2$ was
executed instead.\\
\\
It would be desirable to see whether the class of public announcements, with
$\to$ and $\mapsto$ would be sufficient to construct all tree action
models.
Conversely, using insanity and public announcement event models with $\to$ should be sufficient to construct
all tree action models.
\begin{thm}
Suppose $M = (\Sigma, R, pre, r)$ is a finite tree event model.
An event model $M^T \sim M$ can be constructed by public announcements, $\to$ and
$\mapsto$.
\end{thm}
\begin{proof}
We will show by induction that for any subtree of $M$,$M'$, we can construct a pointed event model
$M^s \sim M'$ by public announcements, $\to$ and $\mapsto$.\\
\\
Suppose $M'$ is a leaf node of $M$.
Then $M'$ is composed of a single action point $\sigma$.
Let $pre(\sigma) = \phi$.
Let $M^s$ be of the form $pub(\phi) \mapsto_A pub(\bot)$.
\end{proof}
It is clear that adding disjoint union to either of these sets of operators
allows us to form all forests of tree event models.
It also provides us with an alternate way to form tree event models.\\
\\
%\FIXME: this isn't true; how to resolve this properly? definition is not sound at the moment
However, we cannot form tree event models with just $\mapsto$.
Consider $M = (\Sigma, R, pre, T)$ such that
\begin{itemize}
	\item $\Sigma = \{\sigma_1, \sigma_2, \sigma_3, \sigma_4\}$
	\item $R_a =
\{(\sigma_1,\sigma_2),(\sigma_1,\sigma_3),(\sigma_2,\sigma_2),(\sigma_3,\sigma_3)\}$
	\item $R_b = \{(\sigma_1,\sigma_3),(\sigma_1,\sigma_4),(\sigma_3,\sigma_3),(\sigma_4,\sigma_4)\}$
	\item $T = \{ \sigma_1 \}$
pre).
\end{itemize}
We cannot form this model using $ \mapsto $, due to $\sim_a \cap \sim_b \neq
\varnothing$.\\
\\
We can form other interesting models besides trees using these operators.
Let $B$, $C \subseteq A$, the set of all agents.
Suppose $ann(\phi)_B$ is the event model of the group announcement of $\phi$.
We define $skip$ as the public announcement of $\top$ to all agents.
Then $ann(\phi)_B \to_C skip$ models all agents in $B$ learning $\phi$ whilst all agents in $C$
believe that nothing has changed.
Similarly, $skip \mapsto_C ann(\phi)_A$ models the announcement of $\phi$ by an external agent that
the agents in $C$ trust, but the agents in $B$ do not.\\
\\
\end{document}
