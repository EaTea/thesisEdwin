\section{Technical preliminaries}
In order to discuss event model synthesis, we first define essential concepts regarding event
models and the semantics of the logics we are working within.

\subsection{Models}

\begin{defn} \label{frame}
	Let $\Sigma$ be a set of atoms and $R: A \to \mathcal{P}(S \times S)$, a function from agents to
	accessibility relations.
	Then the tuple $(\Sigma, R)$ is a frame.
\end{defn}

A frame represents a mathematical structure, but holds no meaningful information.
In order to give meaning and be able to draw conclusions from the frame, we can
construct a valuation function that transforms the frame into a model detailing
information.
\begin{defn} \label{model}
	Let $L$ be a logical language.
	Let $F = (\Sigma, R)$ be a frame, and $A$ a set of agents.
	In the context of epistemic modal logic, $\Sigma$ is a set of atomic knowledge points.
	Let $V: L \to \mathcal{P}(\Sigma)$ be a function mapping any
	well-formed	sentence in $L$ to a subset of $\Sigma$.
	We say $V$ is a valuation function on $F$.\\
	\\
	Then $\krMo = (F, V) = (\Sigma, R, V)$ is a Kripke
	model.
\end{defn}
A multi-pointed model is a model $\krMo = (\Sigma, R, V)$ with a set of designated states, $T$.
When $T = \{s\}$ is a single state, we say that the model is a pointed model and write $M_s$.
We say $\kripkeClass$ is the class of all Kripke models.

\begin{defn} \label{evModel}
	Let $L$ be a logical language.
	Let $F = (\Sigma, R)$ be a frame, and $A$ a set of agents.
	An event model $\aMod{\evMo = (\Sigma, R, pre)}$ with preconditions defined on $\mathcal{L}$ consists of
	\begin{itemize}
		\item a domain $\aMod{\Sigma}$ of possible atomic action points
		\item an accessibility function, $\aMod{R: A \to \mathcal{P}(\Sigma \times
        \Sigma)}$, a function from agents to
		accessibility relations on $\Sigma$.\\
		We refer to $\aMod{R(a)}$ as $\aMod{R_a}$.
		We will refer to all accessible action points from $\aMod{s}$ as
    $\aMod{s R_a}$, and all action points that
		can access $\aMod{t}$ as $\aMod{R_a t}$.
		Furthermore, we say $\aMod{s R_a t}$ means $\aMod{t}$ is
    $\aMod{a}$-accessible from $\aMod{s}$.
		\item a precondition function, $\aMod{pre: \Sigma} \to \mathcal{L}$ which maps an action point to a
		sentence in $\mathcal{L}$
	\end{itemize}
\end{defn}

We adopt the convention that an event model is written using sans-serif fonts.
Pointed and multi-pointed event models are similarly defined to pointed and multi-pointed Kripke
models.
We adopt the convention for pointed event models that $\aMod{\evMo^1 = (\Sigma^1, R^1,
pre^1, T^1)}$ and $\aMod{\evMo^\alpha =
  (\Sigma^\alpha,R^\alpha,pre^\alpha,T^\alpha)}$.
Furthermore, in literature both of the terms event models and action models are used to describe
the same concept, and we use them interchangeably throughout this paper to refer to event models.

\begin{defn} \label{evModelEx}
Let $\kripkeClass = (\Sigma, R, V) \in \kripkeClass$. We define event model
execution for an event model $\aMod{\evMo = (\Sigma,
		R, pre)} \in
\eventClass$ as follows.
The result of executing $\evMo$ on the model $\krMo$ is denoted by $M \otimes N = M' = (\Sigma', R', V')$ where
\begin{itemize}
	\item $\Sigma' = \{(s,\aMod{u}) | s \in \Sigma, \aMod{u \in
    \Sigma} \text{ such that } M_s \models \aMod{pre(u)}\}$
	\item $(s, u) R_a' (t, v) \iff s R_a t \land \aMod{u R_a v}$
	\item $V'((s,u)) = V(s)$
\end{itemize}
We define pointed event model execution as $\krMo_s \otimes
\aMod{\evMo_u}
= (\krMo \otimes \aMod{\evMo})_{(s, \aMod{u})}$.
This pointed model execution is only sensible if and only if $M_s \models
\aMod{pre(u)}$ and thus $(s,\aMod{u})
	\in \Sigma'$.
\end{defn}

We say $\eventClass$ is the class of all event models.

\begin{defn} \label{pub}
Let $\aMod{\evMo = (\{ \sigma \}, R, \{ (\sigma, \phi)\}})$ be an event model.
Let $\aMod{\sigma}$ be a single action point and $\aMod{R_a =
  \{(\sigma, \sigma)\}}$ for each $a \in A$ and $\phi
\in \mathcal{L}$.
Then $M$ is a public announcement of $\phi$.
We say $\publicAnnClass$ is the class of all action models that
are public announcements of a sentence in $L$.
\end{defn}

\begin{defn} \label{insanity}
Let $\aMod{\evMo = (\{ \sigma \}, \varnothing, \{(\sigma, \phi)\})}$ be an action model
where $\phi \in L$ and $\aMod{\sigma}$ is an action point.
$\aMod{\evMo}$ represents the truthful announcement of $\phi$ causing all agents to renounce all their beliefs.
$\insaneClass = \{\aMod{\evMo} | \phi \in L\}$ is the class of all such action models.
\end{defn}
We call this class of models ``insanity models".
This is because after the execution of an insanity model, all agents have renounced every belief
they hold.
They thus believe in everything --- that both propositions $p$ and $\neg p$ hold.
Allowing them to believe such contradictions means that they are effectively insane.

\subsection{Bisimilarity, simulation and refinement}

\begin{defn} \label{bisimKripke}
	Let $\krMo$, $\krMo'$ be Kripke models and $\sim \subseteq \Sigma \times \Sigma'$ be a non-empty binary
	relation such that
	\begin{itemize}
		\item {\bf atoms}: for each $s \in \Sigma$ and $s' \in \Sigma'$ such that $s \sim s'$, $V(s) = V'(s')$
		\item {\bf front-$a$}: for each $s \in \Sigma$ such that $s \sim s'$, for each $t$ such that
		$s R_a t$ then there exists $t'$ such that $s' R_a' t'$ and $t \sim t'$
		\item {\bf back-$a$}: for each $s' \in \Sigma'$ such that $s \sim s'$, for each $t$ such that
		$s' R_a' r'$ then there exists $t$ such that $s R_a t$ and $t \sim t'$
	\end{itemize}
	$\sim$ is a bisimulation between $M$ and $M'$ if and only if {\bf atoms} holds and {\bf front-$a$}
	and {\bf back-$a$} hold for each $a \in A$.
	We denote $M$ and $M'$ being bisimilar by $M \sim M'$.
\end{defn}
% \FIXME: add in citations

\begin{lemma} \label{bisimEquivalence}
	The relation $\sim$ is an equivalence relation.
\end{lemma}

This is a well-known result.
See \cite{blackburn2002modal} by de Rijke, Venema and Blackburn for further reading..

\begin{defn} \label{nBisimKripke}
Let $\krMo_s, \krMo'_{s'} \in \kripkeClass$.
We define $n$-bisimilarity inductively as follows.
We say that $\krMo_s$ is $0$-bisimilar to $\krMo'_{s'}$ if and only if $V(s) = V'(s)$.
Then for $n > 0$ we say that $\krMo_s$ is $n$-bisimilar to $\krMo'_{s'}$ if and only if for every $a \in A$
\begin{itemize}
	\item $M_s$ is $n-1$-bisimilar to $M'_{s'}$
	\item {\bf $n$-front-$a$}: for each $t \in s R_a$, there is a $t' \in s' R'_a$ such that $M_t$ is
	$n-1$-bisimilar to $M'_{t'}$
	\item {\bf $n$-back-$a$}: for each $t' \in s' R'_a$ there is a $t \in s R_a$ such that $M_t$ is
	$n-1$-bisimilar to $M'_{t'}$
\end{itemize}
We denote $\krMo_s$ and $\krMo'_{s'}$ being $n$-bisimilar by $\krMo_s \sim_n
\krMo'_{s'}$.
\end{defn}
For a multi-pointed Kripke model $\krMo_T$ and $\krMo'_{T'}$, we have that
$\krMo_T \sim_n
\krMo'_{T'}$ if and only if for each point $t \in T$ there is a point $t' \in T'$
such that $\krMo_t \sim_n \krMo'_{t'}$ and vice versa.

\begin{defn} \label{refinement}
Let $B \subseteq A$ and $\krMo$ and $\krMo'$ be Kripke models. A non-empty relation $\lesssim \subseteq \Sigma
\times \Sigma'$ is a $B$-simulation if and only if it satisfies {\bf atoms}, {\bf forth-$a$} for
every $a \in A$ and {\bf back-$a$} for every $a \in A \setminus B$.
\end{defn}
If $(\sigma, \sigma') \in \lesssim$ then we say $\krMo'_{\sigma'}$ is a
$B$-simulation of $\krMo_\sigma$ and
$\krMo_\sigma$ a $B$-refinement of $\krMo'_{\sigma'}$.
We write $\krMo_{\sigma} \lesssim \krMo'_{\sigma'}$ or equivalently
$\krMo'_{\sigma'} \gtrsim \krMo_{\sigma}$.

\begin{lemma} \label{refinementPreorder}
The relation $\lesssim_B$ is a preorder.
\end{lemma}
This is shown by van Ditsmarch and French in \cite{van2009simulation}.

\begin{lemma} \label{bisimilarIsRefinement}
Let $\krMo_\sigma, \krMo'_{\sigma'} \in \kripkeClass$ and $B \subseteq A$.
Then $\krMo_\sigma \sim \krMo'_{\sigma'} \implies \krMo_\sigma \lesssim_B \krMo'_{\sigma'}$.
\end{lemma}

This follows trivially from Definition \ref{refinement} and Definition \ref{bisimKripke}.

\begin{defn} \label{brestrict}
Let $B \subseteq A$ and let $\aMod{\evMo} \in \eventClass$. Then $\aMod{\evMo}$ is a $B$-restricted event model if and
only if for every $\aMod{u \in \Sigma}$ and every $\krMo_s \in \kripkeClass$
such that $\krMo_s \models pre(u)$ we
have $\krMo_s \otimes \evMo_u \gtrsim_B \krMo_s$.
We say the class of $B$-restricted action models is $\eventClass_B$.
\end{defn}

\FIXME: citation here

\subsection{Language semantics}
We now discuss the semantics and syntax of several different languages, culminating with language of
arbitrary action model logic which will rely upon each of the languages we discuss.

\begin{defn} \label{propLogic}
Let $\krMo = (\Sigma, R, V) \in \kripkeClass$.
The language of propositional logic $\langProp$ is inductively defined by
\[
	\phi ::= p \text{ } | \text{ } \neg \phi \text{ } | \text{ } (\phi \land \phi)
\]

The interpretation of $\phi \in \langProp$ in the logic $K$ is defined inductively as

\begin{itemize}
	\item $\krMo_s \models p$ iff $p \in V(s)$
	\item $\krMo_s \models \neg \phi$ iff $\krMo_s \not \models \phi$
	\item $\krMo_s \models \phi \land \psi$ iff $\krMo_s \models \phi$ and $\krMo_s \models \psi$
\end{itemize}

for $s \in \Sigma$.
\end{defn}

We will adopt the standard abbreviations for propositional logic, such as $\phi \lor \phi =
\neg(\neg \phi \land \neg \phi)$.
These are defined in \cite{blackburn2002modal}.

\begin{defn} \label{modalLogic}
Let $\krMoM = (\Sigma, R, V) \in \kripkeClass$.
The language of modal logic $\lang$ is $\langProp$ with the additional inductive case
\[
	 \Box_a \phi
\]
The interpretation of $\phi \in \lang$ in the logic $K$ is the same as $\langProp$, with the
additional inductive case
\[
	\krMo_s \models \Box_a \phi \text{ iff for every }t \in s R_a: \krMo_t \models \phi
\]
for $a \in A$ and $s \in \Sigma$.
\end{defn}
The Kripke semantics for modal logic are well-known.
We will adopt the standard abbreviations for Kripke semantics --- see \cite{blackburn2002modal}.\\
\\
In epistemic logics, the formula $\Box_a \phi$ is often read as ``$a$ knows/believes $\phi$", while
its dual operator, $\Diamond_a \phi$ means ``$a$ considers $\phi$ possible".
We also employ the abbreviation $\Box_B \phi$ where $B \subseteq A$ to be $\bigwedge_{b \in B}
\Box_b \phi$.
In the case where $B = A$ we write $\krMo_s \models \Box \phi$.\\
\\
We say that a formula $\phi$ is satisfied by a pointed model Kripke model $\krMo_s \in \kripkeClass$ iff
$\krMo_s \models \phi$.
We say that $\phi$ is satisfied by a model $\krMo = (\Sigma, R, V)$ (denoted by
    $\krMo \models \phi$) iff
for all $\sigma \in \Sigma$, $\krMo_\sigma \models \phi$.
Furthermore, $\phi$ is valid in a class of Kripke models $\kripkeClass$ iff for
every model $\krMo \in
\kripkeClass$, $\krMo \models \phi$.\\
\\
%\FIXME: Add citation
In addition to $\Box_a$ we introduce the cover operator $\cover_a$, following the definition used in
\cite{venemaproofsystems}.
\begin{defn} \label{coverDef}
Let $\Gamma \subseteq \lang$ be a finite set of formulae.
Then
\[
  \cover_a \Gamma \hat{=} \Box_a \bigvee_{\gamma \in \Gamma} \gamma \land
  \bigwedge_{\gamma \in \Gamma} \Diamond_a \gamma
\]
Similarly, if $B \subseteq A$, then $\cover_B \Gamma \hat{=} \bigwedge_{b \in B}
\cover_b \Gamma$.
\end{defn}
We note that this is a simple abbreviation, and we can define $\Box_a$ and
$\Diamond_a$ in terms of it.
$\Box_a \phi \iff \cover_a \phi \lor \cover_a \varnothing$, while $\Diamond_a
\phi \iff \cover_a \{\phi, \top\}$.
$\cover$ is the basis for the axiomatisation of refinement modal logic.\\
\\
Finally, we discuss modal depth.
We define modal depth as follows
\begin{defn} \label{modalDepth}
We define the modal depth of a formula $\phi \in \lang$ ($MD(\phi)$) as follows
\begin{itemize}
	\item $\mDep(p) = 0$ for atomic formula $p$
	\item $\mDep(\top) = \mDep(\bot)$
	\item $\mDep(\neg \phi) = \mDep(\phi)$
	\item $\mDep(\phi \land \psi) = MAX(\mDep(\phi), \mDep(\psi))$
	\item $\mDep(\Box_a \phi) = 1 + \mDep(\phi)$
\end{itemize}
\end{defn}

Next, we build upon our logics to introduce the concepts updates and refinements as modal logics.
We begin by introducing action model logic, as first defined by Baltag, Moss and Solecki in
\cite{baltag1998lpa}.

\begin{defn} \label{actModelLogic}
Let $\krMo = (\Sigma, R, V) \in \kripkeClass$ be a Kripke model and $\aMod{\evMo
  = (\Sigma, R, pre)} \in
\eventClass$ a multi-pointed event model.
The interpretation of $\phi \in \langActEx$ is the same as its interpretation in $\lang$
(\ref{modalLogic}), but with the additional
inductive cases
\begin{itemize}
	\item $\krMo_s \models \sqex{\aMod{\evMo_\sigma}} \phi$ iff $\krMo_s \models
  \phi \implies \krMo_s \otimes \aMod{\evMo_\sigma} \models
	\phi$ (see Definition \ref{evModelEx})
	\item $\krMo_s \models \sqex{\aMod{\evMo_T}} \phi$ iff for every $\aMod{\sigma
    \in T}$, $\krMo_s \models \sqex{\aMod{\evMo_\sigma}} \phi$ 
\end{itemize}
\end{defn}
$\sqex{\aMod{\evMo_\sigma}} \phi$ can be read as ``the successful execution of the informative update modelled by
$\aMod{\evMo_\sigma}$ will result in $\phi$ being true".
Similarly, $\sqex{\aMod{\evMo_T}} \phi$ can be read as ``the successful execution of the informative update
modelled by $\aMod{\evMo_T}$ will result in $\phi$ being true".
If $\aMod{T = \Sigma}$ then we write $M_s \models \sqex{\aMod{\evMo}} \phi$.\\
\\
We adopt the standard convention for the dual operators, with $\anex{
  \aMod{\evMo_\sigma} } \phi$ being
read as ``the successful execution of the informative update modelled by
$\aMod{\evMo_\sigma}$ may result in
$\phi$ being true".
Again, $\anex{ \aMod{\evMo_T} } \phi$ can be read as ``the successful execution of the informative
update modelled by $\aMod{\evMo_T}$ may result in $\phi$ being true".\\
\\
We also introduce refinement modal logic, as first introduced by van Ditmarsch and French in
\cite{van2009simulation}.

\begin{defn} \label{refineLogic}
Let $\krMo = (\Sigma, R, V) \in \kripkeClass$ be a Kripke model.
The interpretation of $\phi \in \langRefine$ in the logic $K_\forall$ is the same as $\lang$
(\ref{modalLogic}), but with the additional inductive case
\[
	\krMo_s \models \forall_B \phi \text{ iff } \forall \krMo'_{s'} \in
  \eventClass \text{ such that } \krMo'_{s'}
	\lesssim_B \krMo_s : \krMo'_{s'} \models \phi
\]
\end{defn}
We read the formula $\forall_B \phi$ as ``for any $B$-refinement, $\phi$ will hold".
Its dual, $\exists_B \phi$ can be read as ``there is a $B$-refinement such that $\phi$ will hold".
As in the previous operations, when $B = A$ we will write $\forall \phi$.
In addition, when $B = \{b\}$ we write $\forall_b$ and $\exists_b$.
Our text interpretation is taken from an interpretation used by Hales, French and Davies in \cite{hales2012refinement}.

\begin{defn} \label{arbActLogic}
The language of arbitrary action model logic, $\langArbAct$ is first defined in \cite{hales13synthesis}.
We inductively define $\langArbAct$ by
\[
	\phi ::= p \text{ } | \text{ } \neg \phi \text{ } | \text{ } \phi \land \phi \text{ } | \text{ } \Box_a \phi \text{ } |
  \text{ }\sqex{N_T} \phi \text{ } | \text{ } \forall_B \phi
\]
for $\aMod{\evMo_T} \in \eventClass$ and $B \subseteq A$.
\end{defn}
$\langArbAct$ is $\langActEx$ with $\forall_B$ and is also $\langRefine$ with $\sqex{N_T}$.

%\FIXME: Add in James' alternate definition for \forall

% \FIXME: Need more motivating text.
\subsubsection{Miscellaneous Semantic Results}
We provide other results that we will use in the main technical findings of this paper.

\begin{defn} \label{bisimEvent}
	Let $\aMod{\evMo, \evMo'} \in \eventClass$ with preconditions defined on $\langArbAct$.
	A non-empty relation $\sim$ on $\aMod{\evMo} \times \aMod{\evMo'}$ is a bisimulation if and only if for every $a \in A$
	and $\aMod{(s, s') \in \sim}$, the following three conditions hold:
	\begin{itemize}
		\item {\bf pre}: $\aMod{pre(s)} \iff \aMod{pre'(s')}$
		\item {\bf forth-$a$}: for every $\aMod{v \in s R_a}$ there is a $\aMod{v'
      \in s' R'_a}$ such that $\aMod{(v,v')} \in \sim$
		\item {\bf back-$a$}: for every $\aMod{v' \in s' R'_a}$ there is a $\aMod{v
      \in s R_a}$ such that $\aMod{(v,v')} \in
		\sim$
	\end{itemize}
	If $\aMod{(s, s') \in \sim}$ we write $\aMod{\evMo_s \sim '\evMo_{s'}}$ to
  denote that $\evMo_s$ and $\evMo'_{s'}$ are bisimilar and
	that there is a bisimulation between $\evMo_s$ and $\evMo'_{s'}$.
\end{defn}

\begin{lemma} \label{eventModelsRefine}
Let $M_\sigma \in \eventClass$ be an event model and let $N_s \in \kripkeClass$ be a Kripke
model such that $N_s \models pre(\sigma)$.
Then $N_s \otimes M_\sigma \lesssim N_s$.
\end{lemma}

\begin{lemma} \label{eventModelEquivalent}
Let $M_\sigma$, $M'_{\sigma'} \in \eventClass$ be event models such that $M_\sigma \sim M'_{\sigma'}$
and let $N_s \in \kripkeClass$ such that $N_s \models pre(\sigma)$.
Then $N_s \otimes M_\sigma \sim N_s \otimes M'_{\sigma'}$.
\end{lemma}

\begin{lemma} \label{nBisimilarKripkeExec}
Let $M_s$, $M'_{s'} \in \kripkeClass$ and $\phi \in \lang$ such that the modal depth of $\phi$,
$MD(\phi) \leq n$.
Suppose that $M_s \sim_{2n} M'_{s'}$ and let $N_t \in
\eventClass$ such that $pre^N(t)$ is of modal depth $n$.
Then $M_s \otimes N_t \models \phi \iff M'_{s'} \otimes N_t \models \phi$.
\end{lemma}

\begin{proof}
We use an inductive proof on the complexity of $\phi$.
We inductively show that $M^1_{(s,t}) = M_s \otimes N_t \models \phi \iff M^2_{(s',t)} = M'_{s'}
\otimes N_t \models \phi$.\\
\\
For our base case, suppose $\phi = p$, where $p$ is an atomic proposition and let
$M^1_{(s,t)} \models \phi$.
\begin{align}
  & \iff p \in V^1_((s,t)) \label{baseOne} \\
  & \iff p \in V(s) \label{baseTwo} \\
  & \iff p \in V'(s) \label{baseThree} \\
  & \iff p \in V^2((s',t)) \label{baseFour} \\
  & \iff M^2_{(s',t)} \models \phi \label{baseFive}
\end{align}
(\ref{baseOne}) follows from the definition of a Kripke model (Definition
\ref{model}).
(\ref{baseTwo}) follows from the definition of event model execution
(Definition \ref{evModelEx}).
(\ref{baseThree}) follows from hypothesis, as $M_s \sim_{2n} M'_{s'} \implies M_s \sim_0 M'_{s'}$
(Definition \ref{nBisimKripke}).
(\ref{baseFour}) follows from the definition of event model execution and
(\ref{baseFive}) follows from the definition of Kripke model (Definition
\ref{model}).
Therefore, we have $M^1_{(s,t)} \models \phi \implies M^2_{(s',t)}$.
The converse follows a similar argument.\\
\\
We handle each of the inductive cases separately now.
Let $\phi = \neg \psi$.
Suppose $M^1_{(s,t)} \models \phi$.
\begin{align}
	& \implies \neg (M^1_{(s,t)} \models \psi) \label{nBisKriNeg1} \\
	& \implies \neg (M^2_{(s',t)} \models \psi) \label{nBisKriNeg2}
\end{align}
(\ref{nBisKriNeg1}) follows from the semantics of propositional logic and the inductive case for
$\neg$ (Lemma \ref{propLogic}).
(\ref{nBisKriNeg2}) follows from the induction hypothesis.\\
\\
Let $\phi = \psi_1 \land \psi_2$.
Suppose $M^1_{(s,t)} \models \phi$.
\begin{align}
	& \implies M^1_{(s,t)} \models \psi_1 \label{nBisKriConj1} \\
	& \iff M^2_{(s',t)} \models \psi_1 \label{nBisKriConj2}
\end{align}
(\ref{nBisKriConj1}) follows from the semantics of propositional logic and the inductive case for
$\land$ (Lemma \ref{propLogic}).
(\ref{nBisKriConj2}) follows from the induction hypothesis.\\
\\
We can employ a similar argument to show that $M^2_{(s',t)} \models \psi_2$ and together with
(\ref{nBisKriConj2}) we have $M^2_{(s',t)} \models \psi_1 \land M^2_{(s',t)} \models \psi_2 \implies
M^2_{(s',t)} \models \psi_1 \land \psi_2 = \phi$.\\
\\
Now, let $\phi = \Diamond_a \psi$ and suppose $M^1_{(s,t)} \models \phi$.
\begin{align}
	& \implies M^1_{(u,v)} \models \psi \text{ for some $(u,v) \in (s,t) R^1_a$} \label{nBisKriMod1} \\
	& \implies M^1_{(u,v)} \models \psi \text{ for some $u \in s R_a$ and $v \in R^N_a$ and $M_s
		\models pre(t)$ and $M_u \models pre(v)$} \label{nBisKriMod2}
\end{align}
(\ref{nBisKriMod1}) follows from the semantics of modal logic and the inductive case for
$\Diamond_a$ (Lemma \ref{modalLogic}).
(\ref{nBisKriMod2}) follows from the definition of event model execution (Definition
		\ref{evModelEx}).\\
\\
From our hypothesis, given that $pre(t) \leq m$ we have that $M_s \sim_{2n} M'_{s'} \implies (M_s \models pre(t) \iff M'_{s'} \models
pre(t))$.
But by the definition of $n$-bisimilarity (Definition \ref{nBisimKripke}), $M_u$ is
$2n-1$-bisimilar to some point $M'_{u'}$.
If $MD(pre^N(v)) \leq n-1$ we have by our induction hypothesis that $M_u \models pre(v) \iff M'_{u'}
\models pre(v)$.\\
\\
Then by the induction hypothesis, $M_u \sim_{2n} M'_{u'} \land MD(\psi) \leq k \implies
M^2_{(u',v)}  \models \psi$.
By the semantics of modal logic (Lemma \ref{modalLogic}) we have that $M^2_{(s',t)} \models
\Diamond_a \psi \implies M^2_{(s',t)} \models \phi$.
\end{proof}

\begin{defn} \label{nBisimEvent}
	Let $M_s, M'_{s'} \in \eventClass$ with preconditions defined on $\langArbAct$.
	We inductively define $n$-bisimilarity for event models.
	We say $M_s$ is $0$-bisimilar to $M'_{s'}$ if and only if $pre(s) \iff pre'(s')$.
	Then for $n>0$ $M_s$ is $n$-bisimilar to $M'_{s'}$ if and only if each of the following hold
	\begin{itemize}
		\item $M_s$ is $n-1$-bisimilar to $M'_{s'}$
		\item {\bf $n$-forth-$a$} for every $t \in s R_a$, there is a $t' \in s' R'_a$ such that $M_t$ is
		$n-1$-bisimilar to $M'_{t'}$
		\item {\bf $n$-back-$a$} for every $t' \in s' R'_a$, there is a $t \in s R_a$ such that $M_t$ is
		$n-1$-bisimilar to $M'_{t'}$
	\end{itemize}
	We write $M_s \sim_n M'_{s'}$ to denote that $M_s$ is $n$-bisimilar to $M'_{s'}$.
\end{defn}

For a multi-pointed event model $M_T$ and $M'_{T'}$, we have that $M_T \sim_n
M'_{T'}$ if and only if for each point $t \in T$ there is a point $t' \in T'$
such that $M_t \sim_n M'_{t'}$ and vice versa.

\begin{lemma} \label{nBisimilarEventExec}
	Let $M_s, M'_{s'} \in \eventClass$ such that $M_s \sim_n M'_{s'}$ and $N_t \in \kripkeClass$.
	For any $\phi \in \lang$ with modal depth $MD(\phi) \leq n$ then $N_t \otimes M_s \models \phi
	\iff N_t \otimes M'_{s'} \models \phi$.
\end{lemma}

\begin{proof}
We use an inductive proof on the complexity of $\phi$.
We inductively show that $M^1_{(t,s}) = N_t \otimes M_s \models \phi \iff M^2_{(t,s')} = N_t \otimes
M'_{s'} \models \phi$.\\
\\
We begin with a base case of $\phi = p$, a single atomic proposition.
Suppose $M^1_{(t,s)} \models \phi$.
Then
\begin{align}
	& \implies p \in V^1_{(t,s)} \label{nBisEvbase1} \\
	& \implies p \in V(t) \label{nBisEvbase2} \\
	& \implies N_t \models pre(s) \label{nBisEvbase4} \\
	& \implies N_t \models pre'(s') \label{nBisEvbase5} \\
	& \implies p \in V^2_{(t,s')} \label{nBisEvbase6}\\
	& \implies M^2_{(t,s')} \models \phi \label{nBisEvbase7}
\end{align}
(\ref{nBisEvbase1}) follows from the semantics for propositional logic (Definition \ref{propLogic}).
(\ref{nBisEvbase2}) and (\ref{nBisEvbase4}) follows from the definition of event model execution (Definition
\ref{evModelEx}).
(\ref{nBisEvbase5}) follows from hypothesis and the definition of $n$-bisimilarity (Definition
\ref{nBisimEvent}).
(\ref{nBisEvbase6}) follows from the definition of event model execution (Definition
\ref{evModelEx}).
Thus, (\ref{nBisEvbase7}) follows from the semantics of propositional logic (Definition
\ref{propLogic}).\\
\\
We go through each of the inductive cases.
Let $\phi = \neg \psi$, and suppose $M^1_{(t,s)} \models \phi$.
Then
\begin{align}
	& \implies \neg (M^1_{(t,s)} \models \psi) \label{nBisEvNeg1} \\
	& \implies \neg (M^2_{(t,s')} \models \psi) \label{nBisEvNeg2} \\
	& \implies M^2_{(t,s')} \models \neg \psi \label{nBisEvNeg3} \\
	& \implies M^2_{(t,s')} \models \phi \label{nBisEvNeg4}
\end{align}
(\ref{nBisEvNeg1}) follows from the semantics of propositional logic (Lemma \ref{propLogic}).
(\ref{nBisEvNeg2}) follows from the induction hypothesis.
(\ref{nBisEvNeg3}) again follows from the semantics of propositional logic (Definition
		\ref{propLogic}) and (\ref{nBisEvNeg4}) is obvious.\\
\\
Let $\phi = \psi_1 \land \psi_2$ and suppose $M^1_{(t,s)} \models \phi$.
Then
\begin{align}
	& \implies M^1_{(t,s}) \models \psi_1 \label{nBisEvCon1} \\
	& \implies M^2_{(t,s'}) \models \psi_1 \label{nBisEvCon2}
\end{align}
(\ref{nBisEvCon1}) follows from the semantics of propositional logic (Lemma \ref{propLogic}).
(\ref{nBisEvCon2}) follows from the induction hypothesis.
Employing a similar process allows us to show that $M^2_{(t,s'}) \models \psi_2$ and together they 
show that $M^2_{(t,s')} \models \phi$.\\
\\
Our final inductive case is to let $a \in A$ and $\phi = \Diamond_a \psi$.
Suppose that $M^1_{(t,s)} \models \phi$.
\begin{align}
	& \iff M^1_{(t,s)} \models \Diamond_a \psi \label{nBisEvMod1} \\
	& \iff M^1_{(v,u)} \models \psi \text{ for some $(v,u) \in (t,s) R^1_a$} \label{nBisEvMod2} \\
	& \iff M^1_{(v,u)} \models \psi \text{ for $v \in t R^N_a$ and $u \in s R_a$ and $N_t \models
		pre(s)$ and $N_v \models pre(u)$} \label{nBisEvMod3} \\
\end{align}

As $M_s \sim_n M'_{s'}$, then there is some $u' \in s R'_a$ such that $M_u \sim_{n-1} M'_{u'}$.
Then we have that $N_v \models pre(u) \iff N_v \models pre'(u)$, since $M_u \sim_{n-1} M'_{u'}
\implies M_u \sim_0 M'_{u'}$.
Then by our induction hypothesis we have that $M^1_{(v,u)} \models \psi \iff M^2_{(v, u')} \models
\psi$.
From this we have (by the semantics of modal logic, in Definition \ref{modalLogic}) $M^2_{(v,u')}
\models \psi \implies M^2_{(t,s')} \models \Diamond_a \psi$.
\end{proof}

%\FIXME: WHO?! Please cite.

\begin{defn} \label{coverNormal}
A formula in cover disjunctive normal form is defined inductively as

\[
	\alpha ::= \pi \land \bigwedge_{b \in B} \cover_b \Gamma_b \text{ } | \text{ } \alpha \lor \alpha
\]

where $\pi \in \langProp$, $B \subseteq A$ and for every $b \in B$, $\Gamma_b$ is a finite set of
formulae in cover disjunctive normal form.
\end{defn}

We note that the above has a base case when $\alpha = \pi$, that is when $B = \varnothing$ or for
each $b \in B \implies \Gamma_b = \varnothing$.

\begin{lemma} \label{allInCoverNormal}
Every formula of $\lang$ is equivalent to a formula in cover disjunctive normal form.
\end{lemma}

This is shown by Bozelli et. al in \cite{DBLPjournalscorrabs12023538}.

\subsection{Axiomatisations}
We will present axiomatisations derived by Hales for $\langArbAct$.
To construct this axiomatisation, we first begin by presenting an axiomatisation for $\lang$, an
axiomatisation for $\langActEx$ and an axiomatisation for $\langRefine$.\\
\\
We say that a formula $\phi$ is provable under an axiomatisation if and only if it can be derived by
some finite sequence of axioms and rules within that axiomatisation.
We denote that $\phi$ is provable by $\vdash \phi$.
When discussing provability, it should be contextually clear which axiomatisation we are using.

\begin{defn} \label{axiomK}
The axiomatisation \AXK consists of the following axioms
\begin{alignat*}{2}
	& \axP && \quad \text{All propositional tautologies} \\
	& \axK && \quad \Box_a(\phi \implies \psi) \implies (\Box_a \phi \implies \Box_a \psi)
\end{alignat*}
and the following rules
\begin{alignat*}{2}
	& \axMP && \quad \text{From $\vdash \phi \implies \psi$ and $\vdash \phi$, infer $\vdash \psi$} \\
	& \axNecK && \quad \text{From $\vdash \phi$, infer $\vdash \Box_a \phi$}
\end{alignat*}
\end{defn}

\begin{lemma} \label{axiomKSoundComplete}
The axiomatisation \AXK is sound and complete with respect to the logic $\lang$.
\end{lemma}

\begin{defn} \label{axiomAML}
The axiomatisation \AXAML contains the axioms and rules from \AXK, as well as the following axioms
\begin{alignat*}{2}
	& \axAP && \quad \sqex{M_\sigma}\pi \iff (pre(\sigma) \implies \pi) \text{ for $\pi \in \langProp$}\\
	& \axAN && \quad \sqex{M_\sigma} \neg \phi \iff (pre(\sigma) \implies \neg \sqex{M_\sigma} \phi)\\
	& \axAC && \quad \sqex{M_\sigma}(\phi \land \psi) \iff (\sqex{M_\sigma}\phi \land \sqex{M_\sigma}\psi\\
	& \axAK && \quad \sqex{M_\sigma}\Box_a\phi \iff (pre(\sigma) \implies \bigwedge_{v \in \sigma R_a}
		\Box_a \sqex{M_v} \phi) \\
	& \axAU && \quad \sqex{M_T} \phi \iff \bigwedge_{u \in T} \sqex{M_u} \phi
\end{alignat*}
and the rule
\[
	\axNecA \quad \text{From $\vdash \phi$ infer $\vdash \sqex{M_\sigma} \phi$}
\]
\end{defn}

\begin{lemma} \label{axiomAMLSoundComplete}
The axiomatisation \AXAML is sound and complete with respect to the logic $\langActEx$.
\end{lemma}

\begin{defn} \label{axiomRML}
The axiomatisation \AXRML contains the axioms and rules from \AXK, as well as the following axioms
\begin{alignat*}{2}
	& \axR && \quad \forall_B (\phi \implies \psi) \implies (\forall_B \phi \implies \forall_B \psi) \\
	& \axRP && \quad \forall_B \pi \iff \pi \text{ where } \pi \in \langProp \\
	& \axRK && \quad\exists_B \cover_a \Gamma_a \iff \bigwedge_{\gamma \in \Gamma} \Diamond_a \exists_B
	\gamma \text{ where } a \in B \\
	& \axRComm && \quad \exists_B \cover_a \Gamma_a \iff \cover_a \{ \exists_B \gamma | \gamma \in
	\Gamma_a\} \text{ where } a \notin B\\
	& \axRDist && \quad \exists_B \bigwedge_{c \in C} \cover_c \Gamma_c \iff \bigwedge_{c \in C}
	\exists_B \cover_c \Gamma_c \text{ where } C \subseteq A
\end{alignat*}
and the rule
\[
	\axNecR \quad \text{From $\vdash \phi$, infer $\vdash \forall_B \phi$}
\]
\end{defn}

\begin{lemma} \label{axiomRMLSoundComplete}
The axiomatisation \AXRML is sound and complete with respect to the logic $\langRefine$.
\end{lemma}

\begin{defn} \label{axiomAAML}
The axiomatisation \AXAAML contains the axioms and rules from \AXRML and \AXAML.
\end{defn}

\begin{thm} \label{axiomAAMLSoundComplete}
The axiomatisation \AXAAML is sound and complete with respect to the logic $\langArbAct$.
\end{thm}
