\chapter{Technical preliminaries} \label{chapter:prelim}
In order to discuss event model synthesis, we first define essential concepts regarding event
models and the semantics of the logics we are working within.

\section{Models} \label{subsec:prelim:models}

\begin{defn} \label{frame}
	Let $S$ be a set of atoms and $R: A \to \mathcal{P}(S \times S)$, a function from agents to
	accessibility relations.
	Then the tuple $(S, R)$ is a {\em frame}.
\end{defn}

If $s, t \in S$, $a \in A$ and $(s,t) \in R(a)$, we write this as $s R_a t$.\\
\\
A frame represents a mathematical structure, but holds no meaningful information.
In order to give meaning and be able to draw conclusions from the frame, we can
construct a valuation function that transforms the frame into a model detailing
information.

\begin{defn} \label{model}
	Let $L$ be a logical language.
	Let $F = (S, R)$ be a frame, and $A$ a set of agents.
	In the context of epistemic modal logic, $S$ is a set of atomic knowledge points.
	Let $V: L \to \mathcal{P}(S)$ be a function mapping any
	well-formed	sentence in $L$ to a subset of $S$.
	We say $V$ is a valuation function on $F$.\\
	\\
	Then $\krMo = (F, V) = (S, R, V)$ is a {\em Kripke model}.
\end{defn}

A multi-pointed model is a model $\krMo = (S, R, V)$ with a set of designated states, $T$.
When $T = \{s\}$ is a single state, we say that the model is a pointed model and write $M_s$.
We say $\kripkeClass$ is the class of all Kripke models.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$\eta$};
    \node[vertex] (2) [right of=1] {$\tau$};
    \path[edge]
          (1) edge node {$A,B$} (2)
              edge [loop left] node {$A,B$} (1)
          (2) edge node {} (1)
              edge [loop right] node {$A,B$} (2);
\end{tikzpicture}
\caption{An example of a Kripke model, $\krMo = (S,R,V)$, as a graph. Here, we can see that
$\eta R_A \tau$, $\tau R_A \eta$, $\eta R_A \eta$ and $\tau R_A \tau$. The same relations apply for
$R_B$.}
\label{figure:exampleModel}
\end{figure}

An example of a Kripke model is given in Figure \ref{figure:exampleModel}.
Here, we have two agents, $A$ and $B$, and two atoms in $S$ ($\eta$ and $\tau$), which we can think
of as possible worlds.
We can frame this example in terms of the coin-tossing game that we discussed earlier, by saying
that $V(\tau) \Rightarrow H$ and $V(\eta) \Rightarrow T$, where $H$ stands for ``the coin is heads"
and $T$ stands for ``the coin is tails".
Both $A$ and $B$ are aware that there are two worlds --- one where the coin is heads ($\tau$), and one
where the coin is tails ($\eta$).
However, as if the coin is hidden from their view, they cannot distinguish between whether $\tau$ or
$\eta$ is the actual state of the world.\\
\\
Kripke models are useful in describing a static situation, but they are not appropriate descriptions
of change.
They cannot describe an informative update that we can formally reason about, which motivates the
need to specify models of updates, which we call {\em action models} or {\em event models}.

\begin{defn} \label{evModel}
	Let $L$ be a logical language.
	Let $F = (S, R)$ be a frame, and $A$ a set of agents.
	An {\em event model} (also known as an {\em action model}) $\aMod{\evMo = (S, R, pre)}$ with preconditions defined on $\mathcal{L}$ consists of
	\begin{itemize}
		\item a domain $\aMod{S}$ of possible atomic action points
		\item an accessibility function, $\aMod{R: A \to \mathcal{P}(S \times
        S)}$, a function from agents to
		accessibility relations on $S$.\\
		We refer to $\aMod{R(a)}$ as $\aMod{R_a}$.
		We will refer to all accessible action points from $\aMod{s}$ as
    $\aMod{s R_a}$, and all action points that
		can access $\aMod{t}$ as $\aMod{R_a t}$.
		Furthermore, we say $\aMod{s R_a t}$ means $\aMod{t}$ is
    $\aMod{a}$-accessible from $\aMod{s}$.
		\item a precondition function, $\aMod{pre: S} \to \mathcal{L}$ which maps an action point to a
		sentence in $\mathcal{L}$
	\end{itemize}
\end{defn}

We adopt the convention that an event model is written using sans-serif fonts.
Pointed and multi-pointed event models are similarly defined to pointed and multi-pointed Kripke
models.
We adopt the convention for pointed event models that $\aMod{\evMo^1 = (S^1, R^1,
pre^1, T^1)}$ and $\aMod{\evMo^\alpha =
  (S^\alpha,R^\alpha,pre^\alpha,T^\alpha)}$.
Furthermore, in literature both of the terms event models and action models are used to describe
the same concept, and we use them interchangeably throughout this paper to refer to event models.
We say $\eventClass$ is the class of all event models.\\
\\
Figure \ref{figure:eventModelExample} gives us an example of an event model, in terms of Angeline, Ben and
their coin-tossing game.
Here, we model the update where Angeline may have cheated and learnt which side up the coin is, or she might not have.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$\evp$};
    \node[vertex] (2) [above right of=1] {$\evu$};
		\node[vertex] (3) [below right of=1] {$\evv$};
    \path[edge]
          (1) edge node {$A,B$} (2)
							edge node {$A,B$} (3)
              edge [loop left] node {$A,B$} (1)
          (2) edge node {} (1)
              edge [loop right] node {$A,B$} (2)
              edge [loop right] node {$A,B$} (3)
					(3) edge node {} (1)
							edge [loop right] node {$A,B$} (3)
							edge node {} (2);
\end{tikzpicture}
\caption{An example of an event model, $\evM = (\evS,\evR,\evpr)$ which we frame in terms of our previous coin-tossing example.
Here, Angeline ($A$) may have learnt whether the coin was heads ($H$) or tails ($T$), or she did not
cheat and learnt nothing at all ($\top$).
We say that $\evpr(\evp) = \top$, $\evpr(\evu) = H$ and $\evpr(\evv) = T$.}
\label{figure:eventModelExample}
\end{figure}

Now that we have established a method of modelling updates, we can specify an update in terms of the
preconditions required to effect an update, and the relations that define the uncertainty between
which specific update was executed.
However, we have not defined update execution, and this model is somewhat pointless without some
idea of how to execute an event model.

\begin{defn} \label{evModelEx}
	Let $\kripkeClass = (S, R, V) \in \kripkeClass$. We define {\em event model
	execution} for an event model $\aMod{\evMo = (S,
		R, pre)} \in
\eventClass$ as follows.
The result of executing $\evMo$ on the model $\krMo$ is denoted by $M \otimes N = M' = (S', R', V')$ where
\begin{itemize}
	\item $S' = \{(s,\aMod{u}) | s \in S, \aMod{u \in
    S} \text{ such that } M_s \models \aMod{pre(u)}\}$
	\item $(s, \aMod{u}) R_a' (t, \aMod{v}) \iff s R_a t \text{ and } \aMod{u R_a v}$
	\item $V'((s,\aMod{u})) = V(s)$
\end{itemize}
We define pointed event model execution as $\krMo_s \otimes
\aMod{\evMo_u}
= (\krMo \otimes \aMod{\evMo})_{(s, \aMod{u})}$.
\end{defn}

Note that we require that $M_s \models \aMod{pre(u)}$, and if this is not the case we end up with a
vacuous, empty Kripke model.
Thus pointed model execution is only sensible if and only if $M_s \models
\aMod{pre(u)}$ and thus $(s,\aMod{u})
	\in S'$.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$s'$};
    \node[vertex] (2) [right of=1] {$t'$};
		\node[vertex] (3) [below of=1] {$s$};
		\node[vertex] (4) [below of=2] {$t$};
    \path[edge]
          (1) edge node {$B$} (2)
							edge node {$B$} (3)
							edge node {$B$} (4)
              edge [loop left] node {$A,B$} (1)
          (2) edge node {} (1)
							edge node {$B$} (3)
							edge node {$B$} (4)
              edge [loop right] node {$A,B$} (2)
					(3) edge node {} (1)
							edge node {} (2)
							edge node {} (4)
							edge [loop left ] node {$A,B$} (3)
					(4) edge node {} (1)
							edge node {} (2)
							edge node {$A,B$} (3)
							edge [loop right] node {$A,B$} (4);
\end{tikzpicture}
\caption{After executing $\evM$ (Figure \ref{figure:eventModelExample}) on $M$ (Figure
\ref{figure:exampleModel}), we get a new event model $M' = (S',R',V') = M \otimes \evM$.
Here $\evs,\evt,\evs',\evt'$ are the new possible worlds, where $V'(s') = V'(s) = H$ and $V'(t') =
V'(t) = T$.
However, we note that in this Kripke model $B$ cannot distinguish any of these worlds apart, whilst
$A$ can distinguish between $s'$ and $t'$ --- this represents $A$ knowing in $s'$ and $t'$ the state
of the coin.}
\label{figure:eventModelPostExecution}
\end{figure}

In Figure \ref{figure:eventModelPostExecution} we use our previous figures to demonstrate event
model execution.
We can see that $s$ would have been the result of executing $\evp$ on $\tau$, whilst executing
$\evu$ on $\tau$ resulted in $s'$.\\
\\
Event model execution allows us to discuss how, given an event model and an update, the Kripke model
(the model of the epistemic situation) changes.
We can now discuss some interesting and useful classes of event models that we will employ later in this work.

\begin{defn} \label{pub}
Let $\aMod{\evMo = (\{ s \}, R, \{ (s, \phi)\}})$ be an event model.
Let $\aMod{s}$ be a single action point and $\aMod{R_a = \{(s, s)\}}$ for each $a \in A$ and $\phi
\in \lang$.
Then $M$ is a {\em public announcement} of $\phi$.
We say $\publicAnnClass$ is the class of all action models that
are public announcements of a sentence in $L$.
\end{defn}

Public announcements are a single action point with one reflexive edge, and they all have the form
as shown in Figure \ref{figure:exampleAnnounce}.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$\evs$};
    \path[edge]
          (1) edge [loop left] node {} (1);
\end{tikzpicture}
\caption{The form of every public announcement, where for $\evM^P_\evs =
((\evS^P,\evR^P,\evpr^P),\evs)$ we have that $\evpr^P(\evs)$ is some sentence in $\lang$.}
\label{figure:exampleAnnounce}
\end{figure}

Our next set of event models are particularly useful in constructing event models.
They are somewhat vacuous, and in terms of knowledge they are somewhat odd by themselves.
Their flexibility as event models due to having no prior relations is useful in being the atoms to
use for our constructions.

\begin{defn} \label{insanity}
Let $\aMod{\evMo = (\{ s \}, \varnothing, \{(s, \phi)\})}$ be an action model
where $\phi \in L$ and $\aMod{s}$ is an action point.
$\aMod{\evMo}$ represents the truthful announcement of $\phi$ causing all agents to renounce all their beliefs.
$\insaneClass = \{\aMod{\evMo} \text{ } | \text{ } \phi \in L\}$ is the class of all such action models.
We call this class of models {\em insanity models}.
\end{defn}

This is because after the execution of an insanity model, all agents have renounced every belief
they hold.
They thus believe in everything --- that both propositions $p$ and $\neg p$ hold.
Allowing them to believe such contradictions means that they have no consistent beliefs, and we
loosely associate this condition with ``insanity" for ease of referencing.
They have the same form as the event model shown in Figure \ref{figure:exampleInsane}.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$\evs$};
\end{tikzpicture}
\caption{The form of every insanity model, where for $\evM^I_\evs =
((\evS^I,\varnothing,\evpr^I),\evs)$ we have that $\evpr^I(\evs)$ is some sentence in $\lang$
Note the lack of a reflexive edge, unlike in Figure \ref{figure:exampleAnnounce}.}
\label{figure:exampleInsane}
\end{figure}

\section{Bisimilarity, simulation and refinement} \label{subsec:prelim:bisimulation}

In order to reason about models, we would like to say whether two models are ``equivalent".
This equivalence should come in the form that presents models as being externally the same.
That is, the same reasonings could be made about two models, despite their structures possibly being
different.

\begin{defn} \label{bisimKripke}
	Let $\krMo$, $\krMo'$ be Kripke models and $\sim \subseteq S \times S'$ be a non-empty binary
	relation such that
	\begin{itemize}
		\item {\bf atoms}: for each $s \in S$ and $s' \in S'$ such that $s \sim s'$, $V(s) = V'(s')$
		\item {\bf front-$a$}: for each $s \in S$ such that $s \sim s'$, for each $t$ such that
		$s R_a t$ then there exists $t'$ such that $s' R_a' t'$ and $t \sim t'$
		\item {\bf back-$a$}: for each $s' \in S'$ such that $s \sim s'$, for each $t$ such that
		$s' R_a' r'$ then there exists $t$ such that $s R_a t$ and $t \sim t'$
	\end{itemize}
	$\sim$ is a {\em bisimulation} between $M$ and $M'$ if and only if {\bf atoms} holds and {\bf front-$a$}
	and {\bf back-$a$} hold for each $a \in A$.
	We denote $M$ and $M'$ being {\em bisimilar} by $M \sim M'$.
\end{defn}

Bisimulation allows us to say that externally, two models are exactly the same.
That is, we can make the same reasonings on one of these models $M$ as we can about the other model
$M'$.
This suggests that bisimulation is actually some sort of equivalence, which is given in Lemma
\ref{bisimEquivalence}.

\begin{lemma} \label{bisimEquivalence}
	The relation $\sim$ is an equivalence relation.
\end{lemma}

This is a well-known result.
See \cite{blackburn2002modal} by de Rijke, Venema and Blackburn for a proof of correctness and
further definitions.\\
\\
We have a notion of absolute equivalence by employing bisimilarity.
However, bisimilarity is an extremely strong notion; it mandates that all reasonings that we make
about one model will be true reasonings for another bisimilar model.
It is useful to have a weaker notion of equivalence, one that mandates that reasonings up to a
subset will be true reasonings for another model.

\begin{defn} \label{nBisimKripke}
Let $\krMo_s, \krMo'_{s'} \in \kripkeClass$.
We define {\em $n$-bisimilarity} inductively as follows.
We say that $\krMo_s$ is {\em $0$-bisimilar} to $\krMo'_{s'}$ if and only if $V(s) = V'(s)$.
Then for $n > 0$ we say that $\krMo_s$ is {\em $n$-bisimilar} to $\krMo'_{s'}$ if and only if for every $a \in A$
\begin{itemize}
	\item $M_s$ is $n-1$-bisimilar to $M'_{s'}$
	\item {\bf $n$-front-$a$}: for each $t \in s R_a$, there is a $t' \in s' R'_a$ such that $M_t$ is
	$n-1$-bisimilar to $M'_{t'}$
	\item {\bf $n$-back-$a$}: for each $t' \in s' R'_a$ there is a $t \in s R_a$ such that $M_t$ is
	$n-1$-bisimilar to $M'_{t'}$
\end{itemize}
We denote $\krMo_s$ and $\krMo'_{s'}$ being $n$-bisimilar by $\krMo_s \sim_n
\krMo'_{s'}$.
\end{defn}

For a multi-pointed Kripke model $\krMo_T$ and $\krMo'_{T'}$, we have that
$\krMo_T \sim_n
\krMo'_{T'}$ if and only if for each point $t \in T$ there is a point $t' \in T'$
such that $\krMo_t \sim_n \krMo'_{t'}$ and vice versa.\\
\\
We now introduce a seemingly tangential idea --- that of a simulation or refinement.
A simulation (and its dual, a refinmenet) preserves positive knowledge --- that is, everything that an agent knows or is certain
about is preserved.
However, a simulation will not necessarily preserve negative knowledge, or the propositions an agent
is uncertain about.

\begin{defn} \label{refinement}
Let $B \subseteq A$ and $\krMo$ and $\krMo'$ be Kripke models. A non-empty relation $\lesssim \subseteq S
\times S'$ is a {\em $B$-simulation} if and only if it satisfies {\bf atoms}, {\bf forth-$a$} for
every $a \in A$ and {\bf back-$a$} for every $a \in A \setminus B$.
If $(s, s') \in \lesssim$ then we say $\krMo'_{s'}$ is a
$B$-simulation of $\krMo_s$ and
$\krMo_s$ a {\em $B$-refinement} of $\krMo'_{s'}$.
We write $\krMo_{s} \lesssim \krMo'_{s'}$ or equivalently
$\krMo'_{s'} \gtrsim \krMo_{s}$.
\end{defn}

This definition is given by Blackburn, de Rijke and Venema in \cite{blackburn2002modal}.\\
\\
Simulations and refinements are powerful because they have a mapping to event models --- that is,
event models and their execution can be characterised by refinements, as shown in Lemma
\ref{eventModelsRefine}.

\begin{lemma} \label{eventModelsRefine}
Let $\aMod{\evMo_s} \in \eventClass$ be an event model and let $\krMo_t \in \kripkeClass$ be a Kripke
model such that $\krMo_t \models \aMod{pre(s)}$.
Then $\krMo_t \otimes \aMod{\evMo} \lesssim \krMo_t$.
\end{lemma}

This result, shown by van Ditsmarsch and French in \cite{van2009simulation}, states that executing
an event model is very similar to a refinement.
More specifically, the resulting Kripke model after execution is a refinement of the model prior to
execution, and we can thus consider an event model to be a refinement.
The concepts of refinements are a necessary step as we discuss language semantics, especially since
refinements are quite powerful concepts that we can (eventually) use to quantify over event models,
and is necessary for our work with constructing event models that are complementary to Hales' work
in \cite{hales13synthesis}.

%\begin{lemma} \label{refinementPreorder}
%The relation $\lesssim_B$ is a preorder.
%\end{lemma}
%
%This is shown by van Ditsmarch and French in \cite{van2009simulation}.
%
%\begin{lemma} \label{bisimilarIsRefinement}
%Let $\krMo_s, \krMo'_{s'} \in \kripkeClass$ and $B \subseteq A$.
%Then $\krMo_s \sim \krMo'_{s'} \Rightarrow \krMo_s \lesssim_B \krMo'_{s'}$.
%\end{lemma}
%
%This follows trivially from Definition \ref{refinement} and Definition \ref{bisimKripke}.
%
%\begin{defn} \label{brestrict}
%Let $B \subseteq A$ and let $\aMod{\evMo} \in \eventClass$. Then $\aMod{\evMo}$ is a $B$-restricted event model if and
%only if for every $\aMod{u \in S}$ and every $\krMo_s \in \kripkeClass$
%such that $\krMo_s \models pre(u)$ we
%have $\krMo_s \otimes \evMo_u \gtrsim_B \krMo_s$.
%We say the class of $B$-restricted action models is $\eventClass_B$.
%\end{defn}
%
%\FIXME: citation here

\section{Language semantics} \label{subsec:prelim:semantics}
We now discuss the semantics and syntax of several different languages, culminating with language of
arbitrary action model logic which will rely upon each of the languages we discuss.
These semantics are powerful constructs that allow us to reason about what is true at a specific
point in a model.

\begin{defn} \label{propLogic}
Let $\krMo = (S, R, V) \in \kripkeClass$ for a group of agents $A$.
The {\em language of propositional logic} $\langProp$ is inductively defined by
\[
	\phi ::= p \text{ } | \text{ } \neg \phi \text{ } | \text{ } (\phi \land \phi)
\]

We discuss what formulae and sentences are true at a point in a Kripke model using $\models$.
The interpretation of $\phi \in \langProp$ in the logic $K$ is thus defined inductively as

\begin{itemize}
	\item $\krMo_s \models p$ iff $p \in V(s)$
	\item $\krMo_s \models \neg \phi$ iff $\krMo_s \not \models \phi$
	\item $\krMo_s \models \phi \land \psi$ iff $\krMo_s \models \phi$ and $\krMo_s \models \psi$
\end{itemize}

for $s \in S$.
\end{defn}

We will adopt the standard abbreviations for propositional logic, such as $\phi \lor \phi =
\neg(\neg \phi \land \neg \phi)$.
These are defined in \cite{blackburn2002modal}.\\
\\
Propositional logic gives us now modal power and no way to discuss knowledge in a logical context.
In order to discuss epistemics and knowledge, we must define the semantics of modal logic.

\begin{defn} \label{modalLogic}
Let $\krMo = (S, R, V) \in \kripkeClass$ for a group of agents $A$.
The {\em language of modal logic} $\lang$ is $\langProp$ with the additional inductive case
\[
	 \Box_a \phi
\]
The interpretation of $\phi \in \lang$ in the logic $K$ is the same as $\langProp$, with the
additional inductive case
\[
	\krMo_s \models \Box_a \phi \text{ iff for every }t \in s R_a: \krMo_t \models \phi
\]
for $a \in A$ and $s \in S$.
\end{defn}
The Kripke semantics for modal logic are well-known.
We will adopt the standard abbreviations for Kripke semantics --- see \cite{blackburn2002modal}.\\
\\
In epistemic logics, the formula $\Box_a \phi$ is often read as ``$a$ knows/believes $\phi$", while
its dual operator, $\Diamond_a \phi$ means ``$a$ considers $\phi$ possible".
We also employ the abbreviation $\Box_B \phi$ where $B \subseteq A$ to be $\bigwedge_{b \in B}
\Box_b \phi$.
In the case where $B = A$ we write $\krMo_s \models \Box \phi$.
For some integer $n$ and $a \in A$, we will take $\Box^n_a \phi$ to be $\Box_a \Box^{n-1}_a \phi$,
and for $\Box^1_a \phi = \Box_a \phi$.\\
\\
We say that a formula $\phi$ is satisfied by a pointed model Kripke model $\krMo_s \in \kripkeClass$ iff
$\krMo_s \models \phi$.
We say that $\phi$ is satisfied by a model $\krMo = (S, R, V)$ (denoted by
    $\krMo \models \phi$) iff
for all $s \in S$, $\krMo_s \models \phi$.
Furthermore, $\phi$ is valid in a class of Kripke models $\kripkeClass$ iff for
every model $\krMo \in
\kripkeClass$, $\krMo \models \phi$.
We show an example of propositional and modal logic senteces that are true at Kripke model points in
Figure \ref{figure:exampleReasonings}.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$s$};
    \node[vertex] (2) [right of=1] {$t$};
    \path[edge]
          (1) edge node {$A,B$} (2)
              edge [loop left] node {$A,B$} (1)
          (2) edge node {} (1)
              edge [loop right] node {$A,B$} (2);
\end{tikzpicture}
\caption{This is the same example as Figure \ref{figure:exampleModel}, but we discuss the reasonings
that we can make about it.
$H$ for ``the coin is Heads" is in $V(s)$ and $T$ for ``the coin is Tails" is in $V(t)$.
We note that here, $M_s \models H$ and $M_t \models T$.
We also note that $M_s \models \Diamond_A H \lor \Diamond_A T$, and $M_t \models \Diamond_A H \lor
\Diamond_A T$.}
\label{figure:exampleReasonings}
\end{figure}

In addition to $\Box_a$ we introduce the cover operator $\cover_a$, following the definition used in
\cite{venemaproofsystems}.
The cover operator forms the basis for the axiomatisations for refinement modal logic, which we use
later.

\begin{defn} \label{coverDef}
Let $\Gamma \subseteq \lang$ be a finite set of formulae.
Then
\[
	\cover_a \Gamma \text{ } \hat{=} \text{ } \Box_a \bigvee_{\gamma \in \Gamma} \gamma \land
  \bigwedge_{\gamma \in \Gamma} \Diamond_a \gamma
\]
Similarly, if $B \subseteq A$, then $\cover_B \Gamma \hat{=} \bigwedge_{b \in B}
\cover_b \Gamma$.
\end{defn}
We note that this is a simple abbreviation, and we can define $\Box_a$ and
$\Diamond_a$ in terms of it.
$\Box_a \phi \iff \cover_a \phi \lor \cover_a \varnothing$, while $\Diamond_a
\phi \iff \cover_a \{\phi, \top\}$.
The cover operator is the basis for the axiomatisation of refinement modal logic.\\
\\
If we defined $\Box_a \phi$ as ``$a$ knows that $\phi$ is true" then the modal depth of a formula is, roughly,
how many times we attached the phrase ``$a$ knows that $\ldots$" to our proposition.
As an example, $\Box_a \Box_a \phi$, which translates to ``$a$ knows that $a$ knows that $\phi$ is
true" has a modal depth of 2.\\
\\
We formally define modal depth as follows

\begin{defn} \label{modalDepth}
We define the {\em modal depth} of a formula $\phi \in \lang$ ($\mDep(\phi)$) as follows
\begin{itemize}
	\item $\mDep(p) = 0$ for atomic formula $p$
	\item $\mDep(\top) = \mDep(\bot)$
	\item $\mDep(\neg \phi) = \mDep(\phi)$
	\item $\mDep(\phi \land \psi) = \max(\mDep(\phi), \mDep(\psi))$
	\item $\mDep(\Box_a \phi) = 1 + \mDep(\phi)$
\end{itemize}
\end{defn}

Within the context of our coin game involving Angline and Ben, modal depth can be used to say
\begin{itemize}
	\item $\mDep(H) = 0$; that is, the modal depth of the propositional atom ``the coin is heads" is 0
	\item $\mDep(\Box_A H) = 1$, or that the modal depth of ``$A$ knows the coin is heads" is 1
	\item $\mDep(\Box_A (H \lor T)) = \mDep(\Box_A(\neg(\neg H \land \neg T))) = 1$
	\item $\mDep(\Diamond_A \Box_A (H)) = \mDep(\neg \Box_A (\neg Box_A (H))) = 2$
\end{itemize}

Next, we build upon our logics to introduce the concepts updates and refinements as modal logics.
We begin by introducing action model logic, as first defined by Baltag, Moss and Solecki in
\cite{baltag1998lpa}.
These give us the semantics for discussing event models in a language context, and we can now start
to treat event models within our language, not simply as models of updates.
This is important, since it now allows us to discuss event models as a language construct, which is
much more a dynamic concept that just as a single event that is being modelled.

\begin{defn} \label{actModelLogic}
Let $\krMo = (S, R, V) \in \kripkeClass$ be a Kripke model and $\aMod{\evMo
  = (S, R, pre)} \in
\eventClass$ a multi-pointed event model for a group of agents $A$.
The interpretation of $\phi \in \langActEx$ --- that is, the {\em language of event model execution} ---  is the same as its interpretation in $\lang$
(\ref{modalLogic}), but with the additional
inductive cases
\begin{itemize}
	\item $\krMo_s \models \sqex{\aMod{\evMo_s}} \phi$ iff $\krMo_s \models
  \phi \Rightarrow \krMo_s \otimes \aMod{\evMo_s} \models
	\phi$ (see Definition \ref{evModelEx})
	\item $\krMo_s \models \sqex{\aMod{\evMo_T}} \phi$ iff for every $\aMod{s
    \in T}$, $\krMo_s \models \sqex{\aMod{\evMo_s}} \phi$ 
\end{itemize}
\end{defn}
$\sqex{\aMod{\evMo_s}} \phi$ can be read as ``the successful execution of the informative update modelled by
$\aMod{\evMo_s}$ will result in $\phi$ being true".
Similarly, $\sqex{\aMod{\evMo_T}} \phi$ can be read as ``the successful execution of the informative update
modelled by $\aMod{\evMo_T}$ will result in $\phi$ being true".
If $\aMod{T = S}$ then we write $M_s \models \sqex{\aMod{\evMo}} \phi$.\\
\\
We adopt the standard convention for the dual operators, with $\anex{
  \aMod{\evMo_s} } \phi$ being
read as ``the successful execution of the informative update modelled by
$\aMod{\evMo_s}$ may result in
$\phi$ being true".
Again, $\anex{ \aMod{\evMo_T} } \phi$ can be read as ``the successful execution of the informative
update modelled by $\aMod{\evMo_T}$ may result in $\phi$ being true".\\
\\
We also introduce refinement modal logic, as first introduced by van Ditmarsch and French in
\cite{van2009simulation}.
Refinement modal logic allows for the quantification over refinements, which in turn (due to Lemma
\ref{eventModelsRefine}) allows us to quantify over all event models.

\begin{defn} \label{refineLogic}
Let $\krMo = (S, R, V) \in \kripkeClass$ be a Kripke model for a group of agents $A$.
The interpretation of $\phi \in \langRefine$ ({\em refinement modal logic}) in the logic $K_\forall$ is the same as $\lang$
(\ref{modalLogic}), but with the additional inductive case
\[
	\krMo_s \models \forall_B \phi \text{ iff } \forall \krMo'_{s'} \in
  \eventClass \text{ such that } \krMo'_{s'}
	\lesssim_B \krMo_s : \krMo'_{s'} \models \phi
\]
\end{defn}

We read the formula $\forall_B \phi$ as ``for any $B$-refinement, $\phi$ will hold".
Its dual, $\exists_B \phi$ can be read as ``there is a $B$-refinement such that $\phi$ will hold".
As in the previous operations, when $B = A$ we will write $\forall \phi$.
In addition, when $B = \{b\}$ we write $\forall_b$ and $\exists_b$.
Our interpretation is taken from an interpretation used by Hales, French and Davies in
\cite{hales2012refinement}.\\
\\
From Lemma \ref{eventModelsRefine}, refinements have a strong relationship to event models,
and the semantics in Definition \ref{refineLogic} are thus applicable to
quantifying over event models.
If we can say that event models are refinements, then we can permit the usage of refinements and the
semantics of refinement modal logic being applied to event models.
This allows us to then quantify over all event models.\\
We can use the semantics of refinement modal logic to say

\begin{itemize}
	\item is there an event model to accomplish $\phi$?	
	\item do all event models accomplish $\psi$?
\end{itemize}

This idea of quantification over event models can be combined with Definition \ref{actModelLogic},
and we can thus discuss both execution and quantification together as a single language.
This gives us the power to both execute, and to query over an arbitrary number of event models.

\begin{defn} \label{arbActLogic}
	The {\em language of arbitrary action model logic}, $\langArbAct$ is first defined in \cite{hales13synthesis}.
We inductively define $\langArbAct$ by
\[
	\phi ::= p \text{ } | \text{ } \neg \phi \text{ } | \text{ } \phi \land \phi \text{ } | \text{ } \Box_a \phi \text{ } |
  \text{ }\sqex{N_T} \phi \text{ } | \text{ } \forall_B \phi
\]
for $\aMod{\evMo_T} \in \eventClass$ and $B \subseteq A$.
\end{defn}

$\langArbAct$ is $\langActEx$ with $\forall_B$ and is also $\langRefine$ with $\sqex{\evMo_\evT}$.

\subsection{Miscellaneous Semantic Results}
We provide other results that we will use in the main technical findings of this paper.
We first turn to an alternate set of definitions, that of providing a parallel result about bisimulations regarding event models.
In Definition \ref{bisimKripke} we discussed bisimulation for Kripke models.
We will extend this now to also cover bisimulation for event models.

\begin{defn} \label{bisimEvent}
	Let $\aMod{\evMo, \evMo'} \in \eventClass$ with preconditions defined on $\langArbAct$.
	A non-empty relation $\sim$ on $\aMod{\evMo} \times \aMod{\evMo'}$ is a {\em bisimulation} if and only if for every $a \in A$
	and $\aMod{(s, s') \in \sim}$, the following three conditions hold:
	\begin{itemize}
		\item {\bf pre}: $\aMod{pre(s)} \iff \aMod{pre'(s')}$
		\item {\bf forth-$a$}: for every $\aMod{v \in s R_a}$ there is a $\aMod{v'
      \in s' R'_a}$ such that $\aMod{(v,v')} \in \sim$
		\item {\bf back-$a$}: for every $\aMod{v' \in s' R'_a}$ there is a $\aMod{v
      \in s R_a}$ such that $\aMod{(v,v')} \in
		\sim$
	\end{itemize}
	If $\aMod{(s, s') \in \sim}$ we write $\aMod{\evMo_s \sim \evMo'_{s'}}$ to
  denote that $\evMo_s$ and $\evMo'_{s'}$ are bisimilar and
	that there is a bisimulation between $\evMo_s$ and $\evMo'_{s'}$.
\end{defn}

\begin{lemma} \label{eventModelEquivalent}
Let $\aMod{\evMo_s}$, $\aMod{\evMo'_{s'}} \in \eventClass$ be event models such that $\aMod{\evMo_s}
\sim \aMod{\evMo'_{s'}}$
and let $\krMo_s \in \kripkeClass$ such that $\krMo_s \models \aMod{pre(s)}$.
Then $\krMo_s \otimes \aMod{\evMo_s} \sim \krMo_s \otimes \aMod{\evMo'_{s'}}$.
\end{lemma}

Lemma \ref{eventModelEquivalent} allows us to compare two event models and say ``after executing
these two event models in the same epistemic situation, the resulting models are bisimilar".
These well-known definitions and results are shown by van der Hoek, Kooi and van Ditsmarsch in
\cite{hoek2008dynamic}.\\
\\
As with before, bisimilarity is a strong condition --- it says that the effects of two bisimilar
event models will be exactly the same.
This is, perhaps, too strong a condition that we might not need.
We thus introduce the idea of $n$-bisimilarity for event models.

%\begin{lemma} \label{nBisimilarKripkeExec}
%Let $\krMo_s$, $\krMo'_{s'} \in \kripkeClass$ and $\phi \in \lang$ such that the modal depth of $\phi$,
%$\mDep(\phi) \leq n$.
%Suppose that $\krMo_s \sim_{2n} \krMo'_{s'}$ and let $\aMod{\evMo_t} \in
%\eventClass$ such that $\aMod{pre(t)}$ is of modal depth $n$.
%Then $\krMo_s \otimes \aMod{\evMo_t} \models \phi \iff \krMo'_{s'} \otimes \aMod{\evMo_t} \models \phi$.
%\end{lemma}
%
%\begin{proof}
%We use an inductive proof on the complexity of $\phi$.
%We inductively show that $\krMo^1_{(s,\aMod{t}}) = \krMo_s \otimes \aMod{\evMo_t} \models \phi \iff
%\krMo^2_{(s',\aMod{t})} = \krMo'_{s'}
%\otimes \aMod{\evMo_t} \models \phi$.\\
%\\
%For our base case, suppose $\phi = p$, where $p$ is an atomic proposition and let
%$\krMo^1_{(s,\aMod{t})} \models \phi$.
%\begin{align}
%  & \iff p \in V^1_((s,\aMod{t})) \label{baseOne} \\
%  & \iff p \in V(s) \label{baseTwo} \\
%  & \iff p \in V'(s) \label{baseThree} \\
%  & \iff p \in V^2((s',\aMod{t})) \label{baseFour} \\
%  & \iff M^2_{(s',\aMod{t})} \models \phi \label{baseFive}
%\end{align}
%(\ref{baseOne}) follows from the definition of a Kripke model (Definition
%\ref{model}).
%(\ref{baseTwo}) follows from the definition of event model execution
%(Definition \ref{evModelEx}).
%(\ref{baseThree}) follows from hypothesis, as $\krMo_s \sim_{2n} \krMo'_{s'} \Rightarrow \krMo_s \sim_0
%\krMo'_{s'}$
%(Definition \ref{nBisimKripke}).
%(\ref{baseFour}) follows from the definition of event model execution and
%(\ref{baseFive}) follows from the definition of Kripke model (Definition
%\ref{model}).
%Therefore, we have $\krMo^1_{(s,\aMod{t})} \models \phi \Rightarrow \krMo^2_{(s',\aMod{t})}$.
%The converse follows a similar argument.\\
%\\
%We handle each of the inductive cases separately now.
%Let $\phi = \neg \psi$.
%Suppose $M^1_{(s,t)} \models \phi$.
%\begin{align}
%	& \Rightarrow \neg (\krMo^1_{(s,\aMod{t})} \models \psi) \label{nBisKriNeg1} \\
%	& \Rightarrow \neg (\krMo^2_{(s',\aMod{t})} \models \psi) \label{nBisKriNeg2}
%\end{align}
%(\ref{nBisKriNeg1}) follows from the semantics of propositional logic and the inductive case for
%$\neg$ (Lemma \ref{propLogic}).
%(\ref{nBisKriNeg2}) follows from the induction hypothesis.\\
%\\
%Let $\phi = \psi_1 \land \psi_2$.
%Suppose $\krMo^1_{(s,\aMod{t})} \models \phi$.
%\begin{align}
%	& \Rightarrow \krMo^1_{(s,\aMod{t})} \models \psi_1 \label{nBisKriConj1} \\
%	& \iff \krMo^2_{(s',\aMod{t})} \models \psi_1 \label{nBisKriConj2}
%\end{align}
%(\ref{nBisKriConj1}) follows from the semantics of propositional logic and the inductive case for
%$\land$ (Lemma \ref{propLogic}).
%(\ref{nBisKriConj2}) follows from the induction hypothesis.\\
%\\
%We can employ a similar argument to show that $\krMo^2_{(s',\aMod{t})} \models \psi_2$ and together with
%(\ref{nBisKriConj2}) we have $\krMo^2_{(s',\aMod{t})} \models \psi_1 \land \krMo^2_{(s',\aMod{t})} \models \psi_2 \Rightarrow
%\krMo^2_{(s',\aMod{t})} \models \psi_1 \land \psi_2 = \phi$.\\
%\\
%Now, let $\phi = \Diamond_a \psi$ and suppose $\krMo^1_{(s,\aMod{t})} \models \phi$.
%\begin{align}
%	& \Rightarrow \krMo^1_{(u,\aMod{v})} \models \psi \text{ for some $(u,\aMod{v}) \in (s,\aMod{t}) R^1_a$} \label{nBisKriMod1} \\
%	& \Rightarrow \krMo^1_{(u,\aMod{v})} \models \psi \text{ for some $u \in s R_a$ and $v \in R^N_a$ and $\krMo_s
%		\models pre(t)$ and $\krMo_u \models \aMod{pre(v)}$} \label{nBisKriMod2}
%\end{align}
%(\ref{nBisKriMod1}) follows from the semantics of modal logic and the inductive case for
%$\Diamond_a$ (Lemma \ref{modalLogic}).
%(\ref{nBisKriMod2}) follows from the definition of event model execution (Definition
%		\ref{evModelEx}).\\
%\\
%From our hypothesis, given that $\aMod{pre(t)} \leq m$ we have that $\krMo_s \sim_{2n} \krMo'_{s'}
%\Rightarrow (\krMo_s \models \aMod{pre(t)} \iff \krMo'_{s'} \models
%\aMod{pre(t)})$.
%But by the definition of $n$-bisimilarity (Definition \ref{nBisimKripke}), $\krMo_u$ is
%$2n-1$-bisimilar to some point $\krMo'_{u'}$.
%If $\mDep(\aMod{pre(v)}) \leq n-1$ we have by our induction hypothesis that $\krMo_u \models
%\aMod{pre(v)} \iff \krMo'_{u'}
%\models \aMod{pre(v)}$.\\
%\\
%Then by the induction hypothesis, $\krMo_u \sim_{2n} \krMo'_{u'} \land \mDep(\psi) \leq k \Rightarrow
%\krMo^2_{(u',\aMod{v})}  \models \psi$.
%By the semantics of modal logic (Lemma \ref{modalLogic}) we have that $\krMo^2_{(s',\aMod{t})} \models
%\Diamond_a \psi \Rightarrow \krMo^2_{(s',\aMod{t})} \models \phi$.
%\end{proof}

\begin{defn} \label{nBisimEvent}
	Let $\aMod{\evMo_s, \evMo'_{s'}} \in \eventClass$ with preconditions defined on $\langArbAct$.
	We inductively define {\em $n$-bisimilarity} for event models.
	We say $\aMod{\evMo_s}$ is {\em $0$-bisimilar} to $\aMod{\evMo'_{s'}}$ if and only if $\aMod{pre(s) \iff
		pre'(s')}$.
	Then for $n > 0$ $\aMod{\evMo_s}$ is $n$-bisimilar to $\aMod{\evMo'_{s'}}$ if and only if each of the following hold
	\begin{itemize}
		\item $\aMod{\evMo_s}$ is $n-1$-bisimilar to $\aMod{\evMo'_{s'}}$
		\item {\bf $n$-forth-$a$} for every $\aMod{t \in s R_a}$, there is a $\aMod{t' \in s' R'_a}$
		such that $\aMod{\evMo_t}$ is
		$n-1$-bisimilar to $\aMod{\evMo'_{t'}}$
		\item {\bf $n$-back-$a$} for every $\aMod{t' \in s' R'_a}$, there is a $\aMod{t \in s R_a}$ such
		that $\aMod{\evMo_t}$ is
		$n-1$-bisimilar to $\aMod{\evMo'_{t'}}$
	\end{itemize}
	We write $\evMo_\evs \sim_n \evMo'_{\evs'}$ to denote that $\evMo_\evs$ is $n$-bisimilar to
	$\evMo'_{\evs'}$.
\end{defn}

For a multi-pointed event model $\aMod{\evMo_T}$ and $\aMod{\evMo'_{T'}}$, we have that $\evMo_\evT \sim_n
\evMo'_{\evT'}$ if and only if for each point $\evt \in \evT$ there is a point $\evt' \in \evT'$
such that $\evMo_\evt \sim_n \evMo'_{\evt'}$ and vice versa.

\begin{lemma} \label{nBisimilarEventExec}
	Let $\evMo_\evs, \evMo'_{\evs'} \in \eventClass$ such that $\evMo_\evs \sim_n \evM'_{\evs'}$ and
	$\krMo_t \in \kripkeClass$.
	For any $\phi \in \lang$ with modal depth $MD(\phi) \leq n$ then $\krMo_t \otimes \evMo_\evs \models \phi
	\iff \krMo_t \otimes \evMo'_{\evs'} \models \phi$.
\end{lemma}

\begin{proof}
We use an inductive proof on the complexity of $\phi$.
We inductively show that $\evMo^1_{(t,\evs}) = \krMo_t \otimes \evMo_\evs \models \phi \iff \evMo^2_{(t,\evs')} = \krMo_t \otimes
\evMo'_{\evs'} \models \phi$.\\
\\
We begin with a base case of $\phi = p$, a single atomic proposition.
Suppose $\evMo^1_{(t,\evs)} \models \phi$.
Then
\begin{align}
	& \Rightarrow p \in V^1_{(t,\evs)} \label{nBisEvbase1} \\
	& \Rightarrow p \in V(t) \label{nBisEvbase2} \\
	& \Rightarrow \krMo_t \models \evpr(\evs) \label{nBisEvbase4} \\
	& \Rightarrow \krMo_t \models \evpr'(\evs') \label{nBisEvbase5} \\
	& \Rightarrow p \in V^2_{(t,\evs')} \label{nBisEvbase6}\\
	& \Rightarrow \evMo^2_{(t,\evs')} \models \phi \label{nBisEvbase7}
\end{align}
(\ref{nBisEvbase1}) follows from the semantics for propositional logic (Definition \ref{propLogic}).
(\ref{nBisEvbase2}) and (\ref{nBisEvbase4}) follows from the definition of event model execution (Definition
\ref{evModelEx}).
(\ref{nBisEvbase5}) follows from hypothesis and the definition of $n$-bisimilarity (Definition
\ref{nBisimEvent}).
(\ref{nBisEvbase6}) follows from the definition of event model execution (Definition
\ref{evModelEx}).
Thus, (\ref{nBisEvbase7}) follows from the semantics of propositional logic (Definition
\ref{propLogic}).\\
\\
We go through each of the inductive cases.
Let $\phi = \neg \psi$, and suppose $\evMo^1_{(t,\evs)} \models \phi$.
Then
\begin{align}
	& \Rightarrow \neg (\evMo^1_{(t,\evs)} \models \psi) \label{nBisEvNeg1} \\
	& \Rightarrow \neg (\evMo^2_{(t,\evs')} \models \psi) \label{nBisEvNeg2} \\
	& \Rightarrow \evMo^2_{(t,\evs')} \models \neg \psi \label{nBisEvNeg3} \\
	& \Rightarrow \evMo^2_{(t,\evs')} \models \phi \label{nBisEvNeg4}
\end{align}
(\ref{nBisEvNeg1}) follows from the semantics of propositional logic (Lemma \ref{propLogic}).
(\ref{nBisEvNeg2}) follows from the induction hypothesis.
(\ref{nBisEvNeg3}) again follows from the semantics of propositional logic (Definition
		\ref{propLogic}) and (\ref{nBisEvNeg4}) is obvious.\\
\\
Let $\phi = \psi_1 \land \psi_2$ and suppose $\evMo^1_{(t,\evs)} \models \phi$.
Then
\begin{align}
	& \Rightarrow \evMo^1_{(t,\evs}) \models \psi_1 \label{nBisEvCon1} \\
	& \Rightarrow \evMo^2_{(t,\evs'}) \models \psi_1 \label{nBisEvCon2}
\end{align}
(\ref{nBisEvCon1}) follows from the semantics of propositional logic (Lemma \ref{propLogic}).
(\ref{nBisEvCon2}) follows from the induction hypothesis.
Employing a similar process allows us to show that $\evMo^2_{(t,\evs'}) \models \psi_2$ and together they 
show that $\evMo^2_{(t,\evs')} \models \phi$.\\
\\
Our final inductive case is to let $a \in A$ and $\phi = \Diamond_a \psi$.
Suppose that $\evMo^1_{(t,\evs)} \models \phi$.
\begin{align}
	& \iff \evMo^1_{(t,\evs)} \models \Diamond_a \psi \label{nBisEvMod1} \\
	& \iff \evMo^1_{(v,\evu)} \models \psi \text{ for some $(v,\evu) \in (t,\evs) R^1_a$} \label{nBisEvMod2} \\
	& \iff \evMo^1_{(v,\evu)} \models \psi \text{ for $v \in t R^\krMo_a$ and $\evu \in \evs R_a$ and $\krMo_t \models
		\evpr(\evs)$ and $\krMo_v \models \evpr(\evu)$} \label{nBisEvMod3} \\
\end{align}

As $\evMo_\evs \sim_n \evMo'_{\evs'}$, then there is some $\evu' \in \evs R'_a$ such that $\evMo_\evu \sim_{n-1} \evMo'_{\evu'}$.
Then we have that $\krMo_v \models \evpr(\evu) \iff \krMo_v \models \evpr'(\evu)$, since $\evMo_\evu \sim_{n-1} \evMo'_{\evu'}
\Rightarrow \evMo_\evu \sim_0 \evMo'_{\evu'}$.
Then by our induction hypothesis we have that $\evMo^1_{(v,\evu)} \models \psi \iff \evMo^2_{(v, \evu')} \models
\psi$.
From this we have (by the semantics of modal logic, in Definition \ref{modalLogic}) $\evMo^2_{(v,\evu')}
\models \psi \Rightarrow \evMo^2_{(t,\evs')} \models \Diamond_a \psi$.
\end{proof}

This result is very similar to Lemma \ref{eventModelEquivalent}.
However, instead of having all the same effects, we say that two $n$-bisimilar event models will
have the same effects, for all effects with a modal depth of up to a modal depth of $n$.\\
\\
%We provide a final result that relies upon Lemma \ref{nBisimilarEventExec} which we will use later
%in this paper.
%
%\begin{lemma} \label{transitiveNBisimilar}
%	Suppose $\evM_\evt$, $\evM'_{\evt'}$ and $\evM''_{\evt''}$ are event models, and let $\krMo_s$ be
%	a Kripke model.
%	Let $\evM_\evt \sim \evM'_{\evt'}$, and for some $n$ a non-negative integer $\evM'_{\evt'} \sim_n
%	\evM''_{\evt''}$.
%	If $\phi$ is a formula with modal depth $k \leq n$ such that $\krMo_s \otimes \evM_\evt \models
%	\phi$, then $\krMo_s \otimes \evM''_{\evt''} \models \phi$.
%\end{lemma}
%\begin{proof}
%	From Lemma \ref{eventModelEquivalent}, we can say that $\evMo_\evt \sim \evMo'_{\evt'}$ and $\krMo_s \otimes \evMo_\evt \models \phi
%	\Rightarrow \krMo_s \otimes \evMo'_{\evt'} \models \phi$.
%	From Lemma \ref{nBisimilarEventExec}, since $\mDep(\phi) = k \leq n$ and $\evM'_{\evt'} \sim_n
%	\evM''_{\evt''}$ and $\krMo_s \otimes \evM'_{\evt'} \models \phi \Rightarrow \krMo_s \otimes
%	\evM''_{\evt''} \models \phi$.
%\end{proof}

Finally, we define cover normal form, which is an important form that is extensively utilised in
refinement modal logic and arbitrary action model logic.

\begin{defn} \label{coverNormal}
	A formula in {\em cover disjunctive normal form} is defined inductively as

\[
	\alpha ::= \pi \land \bigwedge_{b \in B} \cover_b \Gamma_b \text{ } | \text{ } \alpha \lor \alpha
\]

where $\pi \in \langProp$, $B \subseteq A$ and for every $b \in B$, $\Gamma_b$ is a finite set of
formulae in cover disjunctive normal form.
\end{defn}

We note that the above has a base case when $\alpha = \pi$, that is when $B = \varnothing$ or for
each $b \in B \Rightarrow \Gamma_b = \varnothing$.

\begin{lemma} \label{allInCoverNormal}
Every formula of $\lang$ is equivalent to a formula in cover disjunctive normal form.
\end{lemma}

This is shown by Bozelli et. al in \cite{DBLPjournalscorrabs12023538}.
