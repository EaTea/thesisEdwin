\chapter{Technical preliminaries} \label{chapter:prelim}
In order to discuss action model synthesis, we first define essential concepts
regarding action
models and the semantics of the logics we are working within.

\section{Models and action models} \label{subsec:prelim:models}

\begin{defn} \label{frame}
	Let $A$ be a finite set of agents.
	Let $S$ be a set of states and $R: A \to \mathcal{P}(S \times S)$, a function from agents to
	accessibility relations.
	Then the tuple $(S, R)$ is a {\em Kripke frame}.
\end{defn}

If $s, t \in S$, $a \in A$ and $(s,t) \in R(a)$, we write this as $s R_a t$.
We will commonly refer to Kripke frames as simply frames.\\
\\
A frame is a mathematical structure.
However, frames cannot be used to interpret modal formulae because they do not assign meaning to the
atoms.
In order to give meaning and be able to draw conclusions from the frame, we can
construct a valuation function that transforms the frame into a model detailing
information.

\begin{defn} \label{model}
	Let $L$ be a logical language.
	Let $F = (S, R)$ be a frame, and $A$ a finite set of agents.
	In the context of epistemic modal logic, $S$ is a set of atomic knowledge points.
	Let $V: L \to \mathcal{P}(S)$ \footnote{$\mathcal{P}(S)$ is the powerset of $S$.} be a function mapping any
	well-formed	sentence in $L$ to a subset of $S$.
	We say $V$ is a valuation function on $F$.\\
	\\
	Then $\krMo = (F, V) = (S, R, V)$ is a {\em Kripke model}.
\end{defn}

In a similar manner to Kripke frames, we might refer to Kripke models as simply models.\\
\\
A multi-pointed model is a model $\krMo_T = ((S, R, V), T)$ where $T$ is a set of designated states.
When $T = \{s\}$ is a single state, we say that the model is a pointed model and write $M_s$.
We say $\kripkeClass$ is the class of all Kripke models.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$\eta$};
    \node[vertex] (2) [right of=1] {$\tau$};
    \path[edge]
          (1) edge node {$A,B$} (2)
              edge [loop left] node {$A,B$} (1)
          (2) edge node {} (1)
              edge [loop right] node {$A,B$} (2);
\end{tikzpicture}
\caption[Kripke model example of coin-game]{An example of a Kripke model, $\krMo = (S,R,V)$, as a graph. Here, we can see that
$\eta R_A \tau$, $\tau R_A \eta$, $\eta R_A \eta$ and $\tau R_A \tau$. The same relations apply for
$R_B$.}
\label{figure:exampleModel}
\end{figure}

An example of a Kripke model is given in Figure \ref{figure:exampleModel}.
Here, we have two agents, $A$ and $B$, and two states in $S$ ($\eta$ and $\tau$), which we can think
of as possible worlds.
We can frame this example in terms of the coin-tossing game that we discussed earlier, by saying
that $V(\tau) \Rightarrow H$ and $V(\eta) \Rightarrow T$, where $H$ stands for ``the coin is heads"
and $T$ stands for ``the coin is tails".
Both $A$ and $B$ are aware that there is one world where the coin is heads ($\tau$), and one
world where the coin is tails ($\eta$).
However, as if the coin is hidden from their view, they cannot distinguish between whether $\tau$ or
$\eta$ is the actual state of the world.\\
\\
Kripke models are useful in describing a static situation, but they are not appropriate descriptions
of change.
They cannot describe an informative update that we can formally reason about, which motivates the
need to specify models of updates, which we call {\em action models}.

\begin{defn} \label{evModel}
	Let $L$ be a logical language.
	Let $F = (\evS, \evR)$ be a frame, and $A$ a set of agents.
	An {\em action model} $\aMod{\evMo = (S, R, pre)}$ with preconditions defined
  on $L$ consists of
	\begin{itemize}
		\item a domain $\aMod{S}$ of possible atomic action points
		\item an accessibility function, $\aMod{R: A \to \mathcal{P}(S \times
        S)}$, a function from agents to
		accessibility relations on $S$.\\
		We refer to $\aMod{R(a)}$ as $\aMod{R_a}$.
		We will refer to all accessible action points from $\aMod{s}$ as
    $\aMod{s R_a}$, and all action points that
		can access $\aMod{t}$ as $\aMod{R_a t}$.
		Furthermore, we say $\aMod{s R_a t}$ means $\aMod{t}$ is
    $\aMod{a}$-accessible from $\aMod{s}$.
		\item a precondition function, $\aMod{pre: S} \to L$ which maps an action point to a
		sentence in $L$
	\end{itemize}
\end{defn}

We adopt the convention that an action model is written using sans-serif fonts.
Pointed and multi-pointed action models are similarly defined to pointed and multi-pointed Kripke
models.
We adopt the convention for pointed action models that $\aMod{\evMo^1 = (S^1, R^1,
pre^1, T^1)}$ and $\aMod{\evMo^\alpha =
  (S^\alpha,R^\alpha,pre^\alpha,T^\alpha)}$.
We say $\eventClass$ is the class of all action models.\\
\\
Figure \ref{figure:eventModelExample} gives us an example of an action model, in terms of Angeline, Ben and
their coin-tossing game.
Here, we model the update where Angeline may have cheated and learnt which side up the coin is, or she might not have.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$\evp$};
    \node[vertex] (2) [above right of=1] {$\evu$};
		\node[vertex] (3) [below right of=1] {$\evv$};
    \path[edge]
          (1) edge node {$A,B$} (2)
							edge node {$A,B$} (3)
              edge [loop left] node {$A,B$} (1)
          (2) edge node {} (1)
              edge [loop right] node {$A,B$} (2)
              edge [loop right] node {$A,B$} (3)
					(3) edge node {} (1)
							edge [loop right] node {$A,B$} (3)
							edge node {} (2);
\end{tikzpicture}
\caption[Action model example of coin-game update]{An example of an action model, $\evM = (\evS,\evR,\evpr)$ which we frame in terms of our previous coin-tossing example.
Here, Angeline ($A$) may have learnt whether the coin was heads ($H$) or tails ($T$), or she did not
cheat and learnt nothing at all ($\top$).
We say that $\evpr(\evp) = \top$, $\evpr(\evu) = H$ and $\evpr(\evv) = T$.}
\label{figure:eventModelExample}
\end{figure}

Now that we have established a method of modelling updates, we can specify an update in terms of the
preconditions required to effect an update, and the relations that define the uncertainty between
which specific update was executed.
We can now discuss some interesting and useful classes of action models that we will employ later in this work.

\begin{defn} \label{pub}
Let $\aMod{\evMo = (\{ s \}, R, \{ (s, \phi)\}})$ be an action model.
Let $\aMod{s}$ be a single action point and $\aMod{R_a = \{(s, s)\}}$ for each $a \in A$ and $\phi
\in \lang$.
Then $M$ is a {\em public announcement} of $\phi$.
We say $\publicAnnClass$ is the class of all action models that
are public announcements of a sentence in $L$.\\
\\
We write $\phi!$ to indicate that $\phi$ was publicly announced.
\end{defn}

Public announcements are a single action point with one reflexive edge, and they all have the form
as shown in Figure \ref{figure:exampleAnnounce}.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$\evs$};
    \path[edge]
          (1) edge [loop left] node {} (1);
\end{tikzpicture}
\caption[Public announcement form]{The form of every public announcement, where for $\evM^P_\evs =
((\evS^P,\evR^P,\evpr^P),\evs)$ we have that $\evpr^P(\evs)$ is some sentence in $\lang$.}
\label{figure:exampleAnnounce}
\end{figure}

\section{Bisimilarity, simulation and refinement} \label{subsec:prelim:bisimulation}

In order to reason about models, we would like to say whether two models are ``equivalent".
This equivalence should come in the form that presents models as being externally the same at a
given point of a model.
That is, the same reasonings could be made about two points of a model, despite their external
structure and characteristics possibly being different.

\begin{defn} \label{bisimKripke}
	Let $\krMo = (S,R,V)$, $\krMo' = (S',R',V')$ be Kripke models and $\mathcal{R} \subseteq S \times S'$ be a non-empty binary
	relation such that
	\begin{itemize}
		\item {\bf atoms}: for each $s \in S$ and $s' \in S'$ such that $s \mathcal{R} s'$, $V(s) = V'(s')$
		\item {\bf front-$a$}: for each $s \in S$ such that $s \mathcal{R} s'$, for each $t$ such that
		$s R_a t$ then there exists $t'$ such that $s' R_a' t'$ and $t \mathcal{R} t'$
		\item {\bf back-$a$}: for each $s' \in S'$ such that $s \mathcal{R} s'$, for each $t$ such that
		$s' R_a' r'$ then there exists $t$ such that $s R_a t$ and $t \mathcal{R} t'$
	\end{itemize}
	$\mathcal{R}$ is a {\em bisimulation} between $M$ and $M'$ if and only if {\bf atoms} holds and {\bf front-$a$}
	and {\bf back-$a$} hold for each $a \in A$.
	We denote $M$ and $M'$ being {\em bisimilar} by $M \sim M'$.
\end{defn}

Bisimulation allows us to say that externally, two models are exactly the same.
That is, we can make the same reasonings on one of these models $M$ as we can about the other model
$M'$.
This suggests that bisimulation is actually some sort of equivalence, which is given in Lemma
\ref{bisimEquivalence}.

\begin{lemma} \label{bisimEquivalence}
	The relation $\sim$ is an equivalence relation.
\end{lemma}

This is a well-known result.
See \cite{blackburn2002modal} by de Rijke, Venema and Blackburn for a proof of correctness and
further definitions.\\
\\
We have a notion of absolute equivalence by employing bisimilarity.
However, bisimilarity is an extremely strong notion; it mandates that all reasonings that we make
about one model will be true reasonings for another bisimilar model.
It is useful to have a weaker notion of equivalence, one that mandates that reasonings up to a
subset will be true reasonings for another model.

\begin{defn} \label{nBisimKripke}
Let $\krMo_s, \krMo'_{s'} \in \kripkeClass$.
We define {\em $n$-bisimilarity} inductively as follows.
We say that $\krMo_s$ is {\em $0$-bisimilar} to $\krMo'_{s'}$ if and only if $V(s) = V'(s)$.
Then for $n > 0$ we say that $\krMo_s$ is {\em $n$-bisimilar} to $\krMo'_{s'}$ if and only if for every $a \in A$
\begin{itemize}
	\item $M_s$ is $n-1$-bisimilar to $M'_{s'}$
	\item {\bf $n$-front-$a$}: for each $t \in s R_a$, there is a $t' \in s' R'_a$ such that $M_t$ is
	$n-1$-bisimilar to $M'_{t'}$
	\item {\bf $n$-back-$a$}: for each $t' \in s' R'_a$ there is a $t \in s R_a$ such that $M_t$ is
	$n-1$-bisimilar to $M'_{t'}$
\end{itemize}
We denote $\krMo_s$ and $\krMo'_{s'}$ being $n$-bisimilar by $\krMo_s \sim_n
\krMo'_{s'}$.
\end{defn}

For a multi-pointed Kripke model $\krMo_T$ and $\krMo'_{T'}$, we have that
$\krMo_T \sim_n
\krMo'_{T'}$ if and only if for each point $t \in T$ there is a point $t' \in T'$
such that $\krMo_t \sim_n \krMo'_{t'}$ and vice versa.\\
\\
We now introduce a seemingly tangential idea --- that of a simulation or refinement.
A simulation (and its dual, a refinement) preserves positive knowledge --- that is, everything that an agent knows or is certain
about is preserved.
However, a simulation will not necessarily preserve negative knowledge, or the propositions an agent
is uncertain about.

\begin{defn} \label{refinement}
Let $B \subseteq A$ and $\krMo$ and $\krMo'$ be Kripke models. A non-empty relation $\lesssim \subseteq S
\times S'$ is a {\em $B$-simulation} if and only if it satisfies {\bf atoms}, {\bf forth-$a$} for
every $a \in A$ and {\bf back-$a$} for every $a \in A \setminus B$.
If $(s, s') \in \lesssim$ then we say $\krMo'_{s'}$ is a
$B$-simulation of $\krMo_s$ and
$\krMo_s$ a {\em $B$-refinement} of $\krMo'_{s'}$.
We write $\krMo_{s} \lesssim \krMo'_{s'}$ or equivalently
$\krMo'_{s'} \gtrsim \krMo_{s}$.
\end{defn}

This definition is given by Blackburn, de Rijke and Venema in \cite{blackburn2002modal}.
We show examples of Figure \ref{figure:refinementExamples}.

\begin{figure}[ht!]
\centering
\begin{subfigure}[b]{.30\textwidth}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$s$};
    \node[vertex] (2) [right of=1] {$t$};
    \path[edge]
          (1) edge node {$A,B$} (2)
              edge [loop above] node {$A,B$} (1)
          (2) edge node {} (1)
              edge [loop above] node {$A,B$} (2);
\end{tikzpicture}
\caption{A Kripke model $M^1$.}
\label{refinementOne}
\end{subfigure}
~
\begin{subfigure}[b]{.30\textwidth}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$s$};
		\node[vertex] (2) [right of=1] {$t$};
		\node[vertex] (3) [below of=1] {$s'$};
		\node[vertex] (4) [right of=3] {$t'$};
    \path[edge]
          (1) edge [loop above] node {$A,B$} (1)
							edge [<->] node {$A,B$} (2)
							edge [<->] node {$B$} (3)
							edge [<->] node {$B$} (4)
					(2) edge [loop above] node {$A,B$} (2)
							edge [<->] node {$B$} (3)
							edge [<->] node {$B$} (4)
					(3) edge [loop below] node {$A,B$} (3)
							edge [<->] node {$B$} (4)
					(4) edge [loop below] node {$A,B$} (4);
\end{tikzpicture}
\caption{A Kripke model $M^2$.}
\label{refinementTwo}
\end{subfigure}
~
\begin{subfigure}[b]{.30\textwidth}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$s$};
    \path[edge]
          (1) edge [loop left] node {$A,B$} (1);
\end{tikzpicture}
\caption{A Kripke model $M^3$.}
\label{refinementThree}
\end{subfigure}
\caption[Examples of refinements]{In this figure, there are three Kripke models --- each of these
are refinements of each other.
In this case, $M^1 \lesssim M^2$, $M^2 \lesssim M^3$ and $M^1 \lesssim M^3$.}
\label{figure:refinementExamples}
\end{figure}

\section{Language syntax and semantics} \label{subsec:prelim:semantics}

We now discuss the semantics and syntax of several different languages, culminating with the language of
arbitrary action model logic which will rely upon each of the languages we discuss.
These semantics are powerful constructs that allow us to reason about what is true at a specific
point in a model.\\
\\
As the language of arbitrary action model logic relies upon modal logic, action model logic and
refinement modal logic, we discuss the syntax and semantics for each of these languages first.

\begin{defn} \label{modalLogic:syntax}
The {\em language of modal logic}, $\lang$ is inductively defined as
\[
	\phi ::= p \text{ } | \text{ } \neg \phi \text{ } | \text{ } (\phi \land \phi) \text{ } | \text{ } \Box_a \phi
\]
\end{defn}

\begin{defn} \label{modalLogic:semantics}
Let $\krMo = (S, R, V) \in \kripkeClass$ for a group of agents $A$.
The interpretation of $\phi \in \lang$ in the logic $\axK$ is inductively defined as

\begin{itemize}
	\item $\krMo_s \models p$ iff $p \in V(s)$
	\item $\krMo_s \models \neg \phi$ iff $\krMo_s \not \models \phi$
	\item $\krMo_s \models \phi \land \psi$ iff $\krMo_s \models \phi$ and $\krMo_s \models \psi$
	\item $\krMo_s \models \Box_a \phi \text{ iff for every }t \in s R_a: \krMo_t \models \phi$
\end{itemize}

for $a \in A$ and $s \in S$.
\end{defn}

The Kripke semantics for modal logic are well-known.
We will adopt the standard abbreviations for Kripke semantics, such as $\phi \lor \phi =
\neg(\neg \phi \land \neg \phi)$ --- see \cite{blackburn2002modal}.
We note that $\langProp$, the language of propositional logic, is simply $\lang$ without $\Box_a$.\\
\\
In epistemic logics, the formula $\Box_a \phi$ is often read as ``$a$ knows/believes $\phi$", while
its dual operator, $\Diamond_a \phi = \neg \Box_a \neg \phi$ means ``$a$ considers $\phi$ possible".
We also employ the abbreviation $\Box_B \phi$ where $B \subseteq A$ to be $\bigwedge_{b \in B}
\Box_b \phi$.
In the case where $B = A$ we write $\krMo_s \models \Box \phi$.
For some integer $n$ and $a \in A$, we will take $\Box^n_a \phi$ to be $\Box_a \Box^{n-1}_a \phi$,
and for $\Box^1_a \phi = \Box_a \phi$.\\
\\
We say that a formula $\phi$ is {\em satisfied} by a pointed model Kripke model $\krMo_s \in \kripkeClass$ iff
$\krMo_s \models \phi$.
We say that $\phi$ is {\em satisfied} by a model $\krMo = (S, R, V)$ (denoted by
    $\krMo \models \phi$) iff
for all $s \in S$, $\krMo_s \models \phi$.
Furthermore, $\phi$ is {\em valid} in a class of Kripke models $\kripkeClass$ iff for
every model $\krMo \in
\kripkeClass$, $\krMo \models \phi$.
We show an example of propositional and modal logic sentences that are true at Kripke model points in
Figure \ref{figure:exampleReasonings}.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$s$};
    \node[vertex] (2) [right of=1] {$t$};
    \path[edge]
          (1) edge node {$A,B$} (2)
              edge [loop left] node {$A,B$} (1)
          (2) edge node {} (1)
              edge [loop right] node {$A,B$} (2);
\end{tikzpicture}
\caption[Example reasonings at each Kripke point]{This is the same example as Figure \ref{figure:exampleModel}, but we discuss the reasonings
that we can make about it.
$H$ for ``the coin is Heads" is in $V(s)$ and $T$ for ``the coin is Tails" is in $V(t)$.
We note that here, $M_s \models H$ and $M_t \models T$.
We also note that $M_s \models \Diamond_A H \lor \Diamond_A T$, and $M_t \models \Diamond_A H \lor
\Diamond_A T$.}
\label{figure:exampleReasonings}
\end{figure}

In addition to $\Box_a$ we introduce the cover operator $\cover_a$, following the definition used in
\cite{venemaproofsystems}.
The cover operator forms the basis for the axiomatisations for refinement modal logic, which we use
later.

\begin{defn} \label{coverDef}
Let $\Gamma \subseteq \lang$ be a finite set of formulae.
Then
\[
	\cover_a \Gamma \text{ } \hat{=} \text{ } \Box_a \bigvee_{\gamma \in \Gamma} \gamma \land
  \bigwedge_{\gamma \in \Gamma} \Diamond_a \gamma
\]
Similarly, if $B \subseteq A$, then $\cover_B \Gamma \hat{=} \bigwedge_{b \in B}
\cover_b \Gamma$.
\end{defn}
We note that this is a simple abbreviation, and we can define $\Box_a$ and
$\Diamond_a$ in terms of it.
$\Box_a \phi \iff \cover_a \phi \lor \cover_a \varnothing$, while $\Diamond_a
\phi \iff \cover_a \{\phi, \top\}$.
The cover operator is the basis for the axiomatisation of refinement modal logic.\\
\\
If we defined $\Box_a \phi$ as ``$a$ knows that $\phi$ is true" then the modal depth of a formula is, roughly,
how many times we attached the phrase ``$a$ knows that $\ldots$" to our proposition.
As an example, $\Box_a \Box_a \phi$, which translates to ``$a$ knows that $a$ knows that $\phi$ is
true" has a modal depth of 2.\\
\\
We formally define modal depth as follows

\begin{defn} \label{modalDepth}
We define the {\em modal depth} of a formula $\phi \in \lang$ ($\mDep(\phi)$) as follows
\begin{itemize}
	\item $\mDep(p) = 0$ for atomic formula $p$
	\item $\mDep(\top) = \mDep(\bot) = 0$
	\item $\mDep(\neg \phi) = \mDep(\phi)$
	\item $\mDep(\phi \land \psi) = \max(\mDep(\phi), \mDep(\psi))$
	\item $\mDep(\Box_a \phi) = 1 + \mDep(\phi)$
\end{itemize}
\end{defn}

Within the context of our coin game involving Angeline and Ben, modal depth can be used to say
\begin{itemize}
	\item $\mDep(H) = 0$; that is, the modal depth of the propositional atom ``the coin is heads" is 0
	\item $\mDep(\Box_A H) = 1$, or that the modal depth of ``$A$ knows the coin is heads" is 1
	\item $\mDep(\Box_A (H \lor T)) = \mDep(\Box_A(\neg(\neg H \land \neg T))) = 1 + \mDep(\neg(\neg H
		\land \neg T)) = 1 + \mDep(\neg H \land \neg T) = 1 + \max(\mDep(H),\mDep(T)) = 1 + \max(0,0) = 1$
	\item $\mDep(\Diamond_A \Box_A (H)) = \mDep(\neg \Box_A (\neg \Box_A (H))) = 1 + \mDep(\neg(\Box_A(H)))
		= 1 + \mDep(\Box_A(H)) = 2 + \mDep(H) = 2 + 0 =  2$
\end{itemize}

Next, we build upon our logics to introduce the concepts updates and refinements as modal logics.
We begin by introducing action model logic, as first defined by Baltag, Moss and Solecki in
\cite{baltag1998lpa}.
These give us the semantics for discussing action models in a language context, and we can now start
to treat action models within our language, not simply as models of updates.
This is important, since it now allows us to discuss action models as a language construct, which is
much more a dynamic concept that just as a single update that is being modelled.\\
\\
Firstly, we define action model execution.\\
\\
\begin{defn} \label{evModelEx}
	Let $\krMo = (S, R, V) \in \kripkeClass$. We define {\em action model
	execution} for an action model $\aMod{\evMo = (S,
		R, pre)} \in
\eventClass$ as follows.
The result of executing $\evMo$ on the model $\krMo$ is denoted by $M \otimes N = M' = (S', R', V')$ where
\begin{itemize}
	\item $S' = \{(s,\aMod{u}) | s \in S, \aMod{u \in
    S} \text{ such that } M_s \models \aMod{pre(u)}\}$
	\item $(s, \aMod{u}) R_a' (t, \aMod{v}) \iff s R_a t \text{ and } \aMod{u R_a v}$
	\item $V'((s,\aMod{u})) = V(s)$
\end{itemize}
We define pointed action model execution as $\krMo_s \otimes
\aMod{\evMo_u}
= (\krMo \otimes \aMod{\evMo})_{(s, \aMod{u})}$.
\end{defn}

Note that we require that $M_s \models \aMod{pre(u)}$, and if this is not the case we end up with a
vacuous, empty Kripke model.
Thus pointed model execution is only sensible if and only if $M_s \models
\aMod{pre(u)}$ and thus $(s,\aMod{u})
	\in S'$.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
      thick]

    \node[vertex] (1) {$s'$};
    \node[vertex] (2) [right of=1] {$t'$};
		\node[vertex] (3) [below of=1] {$s$};
		\node[vertex] (4) [below of=2] {$t$};
    \path[edge]
          (1) edge node {$B$} (2)
							edge node {$B$} (3)
							edge node {$B$} (4)
              edge [loop left] node {$A,B$} (1)
          (2) edge node {} (1)
							edge node {$B$} (3)
							edge node {$B$} (4)
              edge [loop right] node {$A,B$} (2)
					(3) edge node {} (1)
							edge node {} (2)
							edge node {} (4)
							edge [loop left ] node {$A,B$} (3)
					(4) edge node {} (1)
							edge node {} (2)
							edge node {$A,B$} (3)
							edge [loop right] node {$A,B$} (4);
\end{tikzpicture}
\caption[Kripke model after action model execution]{After executing $\evM$ (Figure \ref{figure:eventModelExample}) on $M$ (Figure
\ref{figure:exampleModel}), we get a new action model $M' = (S',R',V') = M \otimes \evM$.
Here $\evs,\evt,\evs',\evt'$ are the new possible worlds, where $V'(s') = V'(s) = H$ and $V'(t') =
V'(t) = T$.
However, we note that in this Kripke model $B$ cannot distinguish any of these worlds apart, whilst
$A$ can distinguish between $s'$ and $t'$ --- this represents $A$ knowing in $s'$ and $t'$ the state
of the coin.}
\label{figure:eventModelPostExecution}
\end{figure}

In Figure \ref{figure:eventModelPostExecution} we use our previous figures to
demonstrate action model execution.
We can see that $s$ would have been the result of executing $\evp$ on $\tau$, whilst executing
$\evu$ on $\tau$ resulted in $s'$.
Action model execution gives us a well-defined framework to reason about how the Kripke model
(the model of the epistemic situation) changes after an informative update.

\begin{defn} \label{actModelLogic:syntax}
	The {\em language of action model logic}, $\langActEx$ is $\lang$ (Definition
	\ref{modalLogic:syntax}) with the additional inductive case for $\sqex{\evM_\evs}$, where
	$\evM_\evs$ is an action model.
\end{defn}

\begin{defn} \label{actModelLogic:semantics}
Let $\krMo = (S, R, V) \in \kripkeClass$ be a Kripke model and $\aMod{\evMo
  = (S, R, pre)} \in
\eventClass$ a multi-pointed action model for a group of agents $A$.
The interpretation of $\phi \in \langActEx$ --- that is, the {\em language of action model execution} ---  is the same as its interpretation in $\lang$
(Definition \ref{modalLogic:semantics}), but with the additional
inductive cases
\begin{itemize}
	\item $\krMo_s \models \sqex{\aMod{\evMo_s}} \phi$ iff $\krMo_s \models
  \phi \Rightarrow \krMo_s \otimes \aMod{\evMo_s} \models
	\phi$ (see Definition \ref{evModelEx})
	\item $\krMo_s \models \sqex{\aMod{\evMo_T}} \phi$ iff for every $\aMod{s
    \in T}$, $\krMo_s \models \sqex{\aMod{\evMo_s}} \phi$ 
\end{itemize}
\end{defn}

$\sqex{\aMod{\evMo_s}} \phi$ can be read as ``the successful execution of the informative update modelled by
$\aMod{\evMo_s}$ will result in $\phi$ being true".
Similarly, $\sqex{\aMod{\evMo_T}} \phi$ can be read as ``the successful execution of the informative update
modelled by $\aMod{\evMo_T}$ will result in $\phi$ being true".
If $\aMod{T = S}$ then we write $M_s \models \sqex{\aMod{\evMo}} \phi$.\\
\\
We adopt the standard convention for the dual operators, with $\anex{
\aMod{\evMo_s} } \phi ::= \neg \sqex{\evMo_\evs} \neg \phi$ being
read as ``the successful execution of the informative update modelled by
$\aMod{\evMo_s}$ may result in $\phi$ being true".\\
\\
We also introduce refinement modal logic, as first introduced by van Ditmarsch and French in
\cite{van2009simulation}.
Refinement modal logic allows for the quantification over refinements, which in turn (due to Lemma
\ref{eventModelsRefine}) allows us to quantify over all action models.

\begin{defn} \label{refineLogic:syntax}
{\em Refinement modal logic}, $\langRefine$ is $\lang$ (Definition
\ref{modalLogic:syntax}) with the additional inductive case for $\forall_B$, for $B \subseteq A$
where $A$ and $B$ are finite groups of agents.
\end{defn}

\begin{defn} \label{refineLogic:semantics}
Let $\krMo = (S, R, V) \in \kripkeClass$ be a Kripke model for a group of agents $A$.
The interpretation of $\phi \in \langRefine$ ({\em refinement modal logic}) in the logic $K_\forall$ is the same as $\lang$
(Definition \ref{modalLogic:semantics}), but with the additional inductive case
\[
	\krMo_s \models \forall_B \phi \text{ iff for every } \krMo'_{s'} \in
  \eventClass \text{ such that } \krMo'_{s'}
	\lesssim_B \krMo_s : \krMo'_{s'} \models \phi
\]
\end{defn}

We read the formula $\forall_B \phi$ as ``for any $B$-refinement, $\phi$ will hold" (see Definition
\ref{refinement} for a formal treatment on refinements).
Its dual, $\exists_B \phi$ can be read as ``there is a $B$-refinement such that $\phi$ will hold".
As in the previous operations, when $B = A$ we will write $\forall \phi$.
In addition, when $B = \{b\}$ we write $\forall_b$ and $\exists_b$.\\
\\
The intention behind combining refinements with action models is that a refinement represents some
informative update.
Indeed, the operation $\forall \phi$ can be read as ``there is some informative update such that
after its execution, $\phi$ is true".
Lemmas \ref{eventModelsRefine} and \ref{refineHasEventModel} justify this position.

\begin{lemma} \label{eventModelsRefine}
Let $\aMod{\evMo_s} \in \eventClass$ be an action model and let $\krMo_t \in \kripkeClass$ be a Kripke
model such that $\krMo_t \models \aMod{pre(s)}$.
Then $\krMo_t \otimes \aMod{\evMo} \lesssim \krMo_t$.
\end{lemma}

\begin{lemma} \label{refineHasEventModel}
	Let $\krMo_s, \krMo'_{s'} \in \kripkeClass$ be finite models such that $\krMo_s \lesssim
	\krMo'_{s'}$.
	Then there exists $\evM_\evu \in \eventClass$ such that $\krMo_s \otimes \evM_\evu \sim
	\krMo'_{s'}$.
\end{lemma}

These results, shown by van Ditsmarsch and French in \cite{van2009simulation}, state that the result
of an action model execution is a refinement of the original model, and that there is some action
model such that its execution is equivalent to a refinement, up to bisimilarity.
Thus, the resulting Kripke model after execution is a refinement of the model prior to
execution, and we can thus consider the result of an action model execution to be a refinement.\\
\\
If we consider refinements and action models to both capture informative updates,
then the idea of quantification over refinements in Definition \ref{refineLogic:semantics} can be
combined with Definition \ref{actModelLogic:semantics}.
We can thus discuss both execution of action models and quantification together as a single language.
This gives us the power to both execute, and to query over an arbitrary number of action models.
The {\em language of arbitrary action model logic}, $\langArbAct$ is first defined in
\cite{hales13synthesis}, along with a semantic interpretation of $\forall_B$ as quantifying over
action models.

\begin{defn} \label{arbActLogic:syntax}
	We inductively define the {\em language of arbitrary action model logic}, $\langArbAct$ by
\[
	\phi ::= p \text{ } | \text{ } \neg \phi \text{ } | \text{ } \phi \land \phi \text{ } | \text{ } \Box_a \phi \text{ } |
  \text{ }\sqex{N_T} \phi \text{ } | \text{ } \forall_B \phi
\]
where $a \in A$ and $B \subseteq A$, for $A$ a finite set of agents and $p \in \langProp$.
\end{defn}

\begin{defn} \label{arbActLogic:semantics}
	Let $\krMo_s = ((S,R,T),s)$ and $\evM_\evt = ((\evS,\evR,\evT)\evt)$.
	The interpretation of $\phi \in \langArbAct$ is the same as action model logic (Definition
	\ref{actModelLogic:semantics}), with the additional inductive case for $\forall_B$ as defined in
	refinement modal logic (Definition \ref{refineLogic:semantics}).
\end{defn}

$\langArbAct$ is $\langActEx$ with $\forall_B$ and is also $\langRefine$ with $\sqex{\evMo_\evT}$.
%\begin{lemma} \label{refinementPreorder}
%The relation $\lesssim_B$ is a preorder.
%\end{lemma}
%
%This is shown by van Ditsmarch and French in \cite{van2009simulation}.
%
%\begin{lemma} \label{bisimilarIsRefinement}
%Let $\krMo_s, \krMo'_{s'} \in \kripkeClass$ and $B \subseteq A$.
%Then $\krMo_s \sim \krMo'_{s'} \Rightarrow \krMo_s \lesssim_B \krMo'_{s'}$.
%\end{lemma}
%
%This follows trivially from Definition \ref{refinement} and Definition \ref{bisimKripke}.
%
%\begin{defn} \label{brestrict}
%Let $B \subseteq A$ and let $\aMod{\evMo} \in \eventClass$. Then $\aMod{\evMo}$ is a $B$-restricted action model if and
%only if for every $\aMod{u \in S}$ and every $\krMo_s \in \kripkeClass$
%such that $\krMo_s \models pre(u)$ we
%have $\krMo_s \otimes \evMo_u \gtrsim_B \krMo_s$.
%We say the class of $B$-restricted action models is $\eventClass_B$.
%\end{defn}
%
%\FIXME: citation here

\subsection{Miscellaneous Semantic Results}

We provide other results that we will use in the main technical findings of this paper.
We first turn to an alternate set of definitions, that of providing a parallel result about bisimulations regarding action models.
In Definition \ref{bisimKripke} we discussed bisimulation for Kripke models.
We will extend this now to also cover bisimulation for action models.

\begin{defn} \label{bisimEvent}
	Let $\aMod{\evMo, \evMo'} \in \eventClass$ with preconditions defined on $\langArbAct$.
	A non-empty relation $\mathcal{R}$ on $\aMod{\evMo} \times \aMod{\evMo'}$ is a {\em bisimulation} if and only if for every $a \in A$
	and $\aMod{(s, s') \in \mathcal{R}}$, the following three conditions hold:
	\begin{itemize}
		\item {\bf pre}: $\aMod{pre(s)} \iff \aMod{pre'(s')}$
		\item {\bf forth-$a$}: for every $\aMod{v \in s R_a}$ there is a $\aMod{v'
      \in s' R'_a}$ such that $\aMod{(v,v')} \in \mathcal{R}$
		\item {\bf back-$a$}: for every $\aMod{v' \in s' R'_a}$ there is a $\aMod{v
      \in s R_a}$ such that $\aMod{(v,v')} \in
		\mathcal{R}$
	\end{itemize}
	If $\aMod{(s, s') \in \mathcal{R}}$ we write $\aMod{\evMo_s \mathcal{R} \evMo'_{s'}}$ to
  denote that $\evMo_s$ and $\evMo'_{s'}$ are bisimilar and
	that there is a bisimulation between $\evMo_s$ and $\evMo'_{s'}$.
\end{defn}

\begin{lemma} \label{eventModelEquivalent}
Let $\aMod{\evMo_s}$, $\aMod{\evMo'_{s'}} \in \eventClass$ be action models such that $\aMod{\evMo_s}
\sim \aMod{\evMo'_{s'}}$
and let $\krMo_s \in \kripkeClass$ such that $\krMo_s \models \aMod{pre(s)}$.
Then $\krMo_s \otimes \aMod{\evMo_s} \sim \krMo_s \otimes \aMod{\evMo'_{s'}}$.
\end{lemma}

Lemma \ref{eventModelEquivalent} allows us to compare two action models and say ``after executing
these two action models in the same epistemic situation, the resulting models are bisimilar".
These well-known definitions and results are shown by van der Hoek, Kooi and van Ditsmarsch in
\cite{hoek2008dynamic}.\\
\\
As with Kripke model bisimulation, action model bisimilarity is a strong condition --- it says that the effects of two bisimilar
action models will be exactly the same.
This is, perhaps, too strong a condition that we might not need.
We thus introduce the idea of $n$-bisimilarity for action models.

%\begin{lemma} \label{nBisimilarKripkeExec}
%Let $\krMo_s$, $\krMo'_{s'} \in \kripkeClass$ and $\phi \in \lang$ such that the modal depth of $\phi$,
%$\mDep(\phi) \leq n$.
%Suppose that $\krMo_s \sim_{2n} \krMo'_{s'}$ and let $\aMod{\evMo_t} \in
%\eventClass$ such that $\aMod{pre(t)}$ is of modal depth $n$.
%Then $\krMo_s \otimes \aMod{\evMo_t} \models \phi \iff \krMo'_{s'} \otimes \aMod{\evMo_t} \models \phi$.
%\end{lemma}
%
%\begin{proof}
%We use an inductive proof on the complexity of $\phi$.
%We inductively show that $\krMo^1_{(s,\aMod{t}}) = \krMo_s \otimes \aMod{\evMo_t} \models \phi \iff
%\krMo^2_{(s',\aMod{t})} = \krMo'_{s'}
%\otimes \aMod{\evMo_t} \models \phi$.\\
%\\
%For our base case, suppose $\phi = p$, where $p$ is an atomic proposition and let
%$\krMo^1_{(s,\aMod{t})} \models \phi$.
%\begin{align}
%  & \iff p \in V^1_((s,\aMod{t})) \label{baseOne} \\
%  & \iff p \in V(s) \label{baseTwo} \\
%  & \iff p \in V'(s) \label{baseThree} \\
%  & \iff p \in V^2((s',\aMod{t})) \label{baseFour} \\
%  & \iff M^2_{(s',\aMod{t})} \models \phi \label{baseFive}
%\end{align}
%(\ref{baseOne}) follows from the definition of a Kripke model (Definition
%\ref{model}).
%(\ref{baseTwo}) follows from the definition of action model execution
%(Definition \ref{evModelEx}).
%(\ref{baseThree}) follows from hypothesis, as $\krMo_s \sim_{2n} \krMo'_{s'} \Rightarrow \krMo_s \sim_0
%\krMo'_{s'}$
%(Definition \ref{nBisimKripke}).
%(\ref{baseFour}) follows from the definition of action model execution and
%(\ref{baseFive}) follows from the definition of Kripke model (Definition
%\ref{model}).
%Therefore, we have $\krMo^1_{(s,\aMod{t})} \models \phi \Rightarrow \krMo^2_{(s',\aMod{t})}$.
%The converse follows a similar argument.\\
%\\
%We handle each of the inductive cases separately now.
%Let $\phi = \neg \psi$.
%Suppose $M^1_{(s,t)} \models \phi$.
%\begin{align}
%	& \Rightarrow \neg (\krMo^1_{(s,\aMod{t})} \models \psi) \label{nBisKriNeg1} \\
%	& \Rightarrow \neg (\krMo^2_{(s',\aMod{t})} \models \psi) \label{nBisKriNeg2}
%\end{align}
%(\ref{nBisKriNeg1}) follows from the semantics of propositional logic and the inductive case for
%$\neg$ (Lemma \ref{propLogic}).
%(\ref{nBisKriNeg2}) follows from the induction hypothesis.\\
%\\
%Let $\phi = \psi_1 \land \psi_2$.
%Suppose $\krMo^1_{(s,\aMod{t})} \models \phi$.
%\begin{align}
%	& \Rightarrow \krMo^1_{(s,\aMod{t})} \models \psi_1 \label{nBisKriConj1} \\
%	& \iff \krMo^2_{(s',\aMod{t})} \models \psi_1 \label{nBisKriConj2}
%\end{align}
%(\ref{nBisKriConj1}) follows from the semantics of propositional logic and the inductive case for
%$\land$ (Lemma \ref{propLogic}).
%(\ref{nBisKriConj2}) follows from the induction hypothesis.\\
%\\
%We can employ a similar argument to show that $\krMo^2_{(s',\aMod{t})} \models \psi_2$ and together with
%(\ref{nBisKriConj2}) we have $\krMo^2_{(s',\aMod{t})} \models \psi_1 \land \krMo^2_{(s',\aMod{t})} \models \psi_2 \Rightarrow
%\krMo^2_{(s',\aMod{t})} \models \psi_1 \land \psi_2 = \phi$.\\
%\\
%Now, let $\phi = \Diamond_a \psi$ and suppose $\krMo^1_{(s,\aMod{t})} \models \phi$.
%\begin{align}
%	& \Rightarrow \krMo^1_{(u,\aMod{v})} \models \psi \text{ for some $(u,\aMod{v}) \in (s,\aMod{t}) R^1_a$} \label{nBisKriMod1} \\
%	& \Rightarrow \krMo^1_{(u,\aMod{v})} \models \psi \text{ for some $u \in s R_a$ and $v \in R^N_a$ and $\krMo_s
%		\models pre(t)$ and $\krMo_u \models \aMod{pre(v)}$} \label{nBisKriMod2}
%\end{align}
%(\ref{nBisKriMod1}) follows from the semantics of modal logic and the inductive case for
%$\Diamond_a$ (Lemma \ref{modalLogic}).
%(\ref{nBisKriMod2}) follows from the definition of action model execution (Definition
%		\ref{evModelEx}).\\
%\\
%From our hypothesis, given that $\aMod{pre(t)} \leq m$ we have that $\krMo_s \sim_{2n} \krMo'_{s'}
%\Rightarrow (\krMo_s \models \aMod{pre(t)} \iff \krMo'_{s'} \models
%\aMod{pre(t)})$.
%But by the definition of $n$-bisimilarity (Definition \ref{nBisimKripke}), $\krMo_u$ is
%$2n-1$-bisimilar to some point $\krMo'_{u'}$.
%If $\mDep(\aMod{pre(v)}) \leq n-1$ we have by our induction hypothesis that $\krMo_u \models
%\aMod{pre(v)} \iff \krMo'_{u'}
%\models \aMod{pre(v)}$.\\
%\\
%Then by the induction hypothesis, $\krMo_u \sim_{2n} \krMo'_{u'} \land \mDep(\psi) \leq k \Rightarrow
%\krMo^2_{(u',\aMod{v})}  \models \psi$.
%By the semantics of modal logic (Lemma \ref{modalLogic}) we have that $\krMo^2_{(s',\aMod{t})} \models
%\Diamond_a \psi \Rightarrow \krMo^2_{(s',\aMod{t})} \models \phi$.
%\end{proof}

\begin{defn} \label{nBisimEvent}
	Let $\aMod{\evMo_s, \evMo'_{s'}} \in \eventClass$ with preconditions defined on $\langArbAct$.
	We inductively define {\em $n$-bisimilarity} for action models.
	We say $\aMod{\evMo_s}$ is {\em $0$-bisimilar} to $\aMod{\evMo'_{s'}}$ if and only if $\aMod{pre(s) \iff
		pre'(s')}$.
	Then for $n > 0$ $\aMod{\evMo_s}$ is $n$-bisimilar to $\aMod{\evMo'_{s'}}$ if and only if each of the following hold
	\begin{itemize}
		\item $\aMod{\evMo_s}$ is $n-1$-bisimilar to $\aMod{\evMo'_{s'}}$
		\item {\bf $n$-forth-$a$} for every $\aMod{t \in s R_a}$, there is a $\aMod{t' \in s' R'_a}$
		such that $\aMod{\evMo_t}$ is
		$n-1$-bisimilar to $\aMod{\evMo'_{t'}}$
		\item {\bf $n$-back-$a$} for every $\aMod{t' \in s' R'_a}$, there is a $\aMod{t \in s R_a}$ such
		that $\aMod{\evMo_t}$ is
		$n-1$-bisimilar to $\aMod{\evMo'_{t'}}$
	\end{itemize}
	We write $\evMo_\evs \sim_n \evMo'_{\evs'}$ to denote that $\evMo_\evs$ is $n$-bisimilar to
	$\evMo'_{\evs'}$.
\end{defn}

For a multi-pointed action model $\aMod{\evMo_T}$ and $\aMod{\evMo'_{T'}}$, we have that $\evMo_\evT \sim_n
\evMo'_{\evT'}$ if and only if for each point $\evt \in \evT$ there is a point $\evt' \in \evT'$
such that $\evMo_\evt \sim_n \evMo'_{\evt'}$ and vice versa.

\begin{lemma} \label{nBisimilarEventExec}
	Let $\evMo_\evs, \evMo'_{\evs'} \in \eventClass$ such that $\evMo_\evs \sim_n \evM'_{\evs'}$ and
	$\krMo_t \in \kripkeClass$.
	For any $\phi \in \lang$ with modal depth $MD(\phi) \leq n$ then $\krMo_t \otimes \evMo_\evs \models \phi
	\iff \krMo_t \otimes \evMo'_{\evs'} \models \phi$.
\end{lemma}

\begin{proof}
	See the proof given in Appendix \ref{proof:nBisimilarEventExec} for the full proof.
\end{proof}

This result is very similar to Lemma \ref{eventModelEquivalent}.
However, instead of having all the same effects, we say that two $n$-bisimilar action models will
have the same effects, for all effects with a modal depth of up to a modal depth of $n$.\\
\\
Simulations and refinements are powerful because they have a mapping to action models --- that is,
action models and their execution can be characterised by refinements, as shown in Lemma
\ref{eventModelsRefine}.

%We provide a final result that relies upon Lemma \ref{nBisimilarEventExec} which we will use later
%in this paper.
%
%\begin{lemma} \label{transitiveNBisimilar}
%	Suppose $\evM_\evt$, $\evM'_{\evt'}$ and $\evM''_{\evt''}$ are action models, and let $\krMo_s$ be
%	a Kripke model.
%	Let $\evM_\evt \sim \evM'_{\evt'}$, and for some $n$ a non-negative integer $\evM'_{\evt'} \sim_n
%	\evM''_{\evt''}$.
%	If $\phi$ is a formula with modal depth $k \leq n$ such that $\krMo_s \otimes \evM_\evt \models
%	\phi$, then $\krMo_s \otimes \evM''_{\evt''} \models \phi$.
%\end{lemma}
%\begin{proof}
%	From Lemma \ref{eventModelEquivalent}, we can say that $\evMo_\evt \sim \evMo'_{\evt'}$ and $\krMo_s \otimes \evMo_\evt \models \phi
%	\Rightarrow \krMo_s \otimes \evMo'_{\evt'} \models \phi$.
%	From Lemma \ref{nBisimilarEventExec}, since $\mDep(\phi) = k \leq n$ and $\evM'_{\evt'} \sim_n
%	\evM''_{\evt''}$ and $\krMo_s \otimes \evM'_{\evt'} \models \phi \Rightarrow \krMo_s \otimes
%	\evM''_{\evt''} \models \phi$.
%\end{proof}

Finally, we define cover disjunctive normal form, which is an important form that is extensively utilised in
refinement modal logic and arbitrary action model logic.

\begin{defn} \label{coverNormal}
	A formula in {\em cover disjunctive normal form} is defined inductively as

\[
	\alpha ::= \pi \land \bigwedge_{b \in B} \cover_b \Gamma_b \text{ } | \text{ } \alpha \lor \alpha
\]

where $\pi \in \langProp$, $B \subseteq A$ and for every $b \in B$, $\Gamma_b$ is a finite set of
formulae in cover disjunctive normal form.
\end{defn}

We note that the above has a base case when $\alpha = \pi$, that is when $B = \varnothing$ or for
each $b \in B \Rightarrow \Gamma_b = \varnothing$.
The original definition for cover disjunctive normal form was originally defined in
\cite{van2010future}.

\begin{lemma} \label{allInCoverNormal}
Every formula of $\lang$ is equivalent to a formula in cover disjunctive normal form.
\end{lemma}

This is shown by Bozelli et. al in \cite{DBLPjournalscorrabs12023538}.
